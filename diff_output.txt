diff --git a/.gitignore b/.gitignore
index e7823b2..f4ccd5b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,5 @@
 CMakeFiles/
 project_generator.sh
 pointer_check.py
-*.log
 
 # *** end of file ***
diff --git a/.vscode/settings.json b/.vscode/settings.json
index 0f47805..f73de17 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -8,7 +8,6 @@
         "socket_io.h": "c",
         "socket_manager.h": "c",
         "event_handler.h": "c",
-        "utilities.h": "c",
-        "bcm2835.h": "c"
+        "utilities.h": "c"
     }
 }
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
deleted file mode 100644
index 5235cd8..0000000
--- a/.vscode/tasks.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "version": "2.0.0",
-    "tasks": [
-        {
-            "label": "Build All",
-            "type": "shell",
-            "command": "make",
-            "args": ["all"],
-            "group": "build",
-            "problemMatcher": ["$gcc"],
-            "detail": "Build all architectures."
-        },
-        {
-            "label": "Build Release",
-            "type": "shell",
-            "command": "make",
-            "args": ["release"],
-            "group": "build",
-            "problemMatcher": ["$gcc"],
-            "detail": "Build release configuration for x86_64."
-        },
-        {
-            "label": "Build Debug",
-            "type": "shell",
-            "command": "make",
-            "args": ["debug"],
-            "group": {
-                "kind": "build",
-                "isDefault": true
-            },
-            "problemMatcher": ["$gcc"],
-            "detail": "Build debug configuration for x86_64."
-        },
-        {
-            "label": "Build AARCH64",
-            "type": "shell",
-            "command": "make",
-            "args": ["aarch64"],
-            "group": "build",
-            "problemMatcher": ["$gcc"],
-            "detail": "Build release configuration for aarch64."
-        },
-        {
-            "label": "Clean",
-            "type": "shell",
-            "command": "make",
-            "args": ["clean"],
-            "group": "build",
-            "problemMatcher": [],
-            "detail": "Clean the build directory."
-        }
-    ]
-}
diff --git a/Makefile b/Makefile
index 72831ea..a0739e4 100644
--- a/Makefile
+++ b/Makefile
@@ -41,16 +41,10 @@ debug: ARCH = x86_64
 debug: build
 
 # aarch64
-aarch64_release: BUILD_TYPE = Release
-aarch64_release: ARCH = aarch64
-aarch64_release: TOOLCHAIN = -DCMAKE_TOOLCHAIN_FILE=$(AARCH64_TOOLCHAIN)
-aarch64_release: build
-
-# aarch64
-aarch64_debug: BUILD_TYPE = Debug
-aarch64_debug: ARCH = aarch64
-aarch64_debug: TOOLCHAIN = -DCMAKE_TOOLCHAIN_FILE=$(AARCH64_TOOLCHAIN)
-aarch64_debug: build
+aarch64: BUILD_TYPE = Release
+aarch64: ARCH = aarch64
+aarch64: TOOLCHAIN = -DCMAKE_TOOLCHAIN_FILE=$(AARCH64_TOOLCHAIN)
+aarch64: build
 
 build:
 	@cmake -S . -B $(BUILD_DIR)/$(ARCH) -DCMAKE_BUILD_TYPE=$(BUILD_TYPE) $(TOOLCHAIN)
diff --git a/cmake/checks/tidy-checks.cmake b/cmake/checks/tidy-checks.cmake
index c3e213a..5877bbe 100644
--- a/cmake/checks/tidy-checks.cmake
+++ b/cmake/checks/tidy-checks.cmake
@@ -52,7 +52,7 @@ string(CONCAT CLANG_TIDY_CHECKS
     "${BUG_PRONE_CHECKS_EXCLUSIONS}"
 )
 
-find_program(CLANG_TIDY_EXE NAMES "clang-tidy-14" REQUIRED)
+find_program(CLANG_TIDY_EXE NAMES "clang-tidy" REQUIRED)
 set(CMAKE_C_CLANG_TIDY
     "clang-tidy" "-checks=${CLANG_TIDY_CHECKS}"
 )
diff --git a/cmake/libraries/add_all_libs.cmake b/cmake/libraries/add_all_libs.cmake
index ed44bd4..300dd13 100644
--- a/cmake/libraries/add_all_libs.cmake
+++ b/cmake/libraries/add_all_libs.cmake
@@ -7,21 +7,21 @@
 
 function(add_all_libs)
     # Add libraries specifying their directories
-    add_lib(Common DIRS "libraries/Common")
-    add_lib(Math DIRS "libraries/Math")
+    add_lib(Common DIRS libraries/Common)
+    add_lib(Math DIRS libraries/Math)
     add_lib(DSA DIRS 
-        "libraries/DSA/adjacency_list" 
-        "libraries/DSA/adjacency_matrix"
-        "libraries/DSA/hash_table"
-        "libraries/DSA/linked_list"
-        "libraries/DSA/queue"
-        "libraries/DSA/stack"
-        "libraries/DSA/vector"
+        libraries/DSA/adjacency_list 
+        libraries/DSA/adjacency_matrix 
+        libraries/DSA/hash_table
+        libraries/DSA/linked_list
+        libraries/DSA/queue
+        libraries/DSA/stack
+        libraries/DSA/vector
     )
-    add_lib(Threading DIRS "libraries/Threading")
+    add_lib(Threading DIRS libraries/Threading)
     add_lib(Networking DIRS
-        "libraries/Networking/common"
-        "libraries/Networking/tcp_server"
+        libraries/Networking/common
+        libraries/Networking/tcp_server
     )
     
     # Setup inter-library dependencies
diff --git a/cmake/libraries/add_lib.cmake b/cmake/libraries/add_lib.cmake
index e8de425..5582d10 100644
--- a/cmake/libraries/add_lib.cmake
+++ b/cmake/libraries/add_lib.cmake
@@ -12,33 +12,18 @@ function(add_lib LIB_NAME)
     set(multiValueArgs DIRS)
     cmake_parse_arguments(LIB "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
 
-    # Debugging message to check parsed directories
-    message(STATUS "Adding library: ${LIB_NAME}")
-    message(STATUS "LIB_DIRS: ${LIB_DIRS}")
-
     foreach(DIR IN LISTS LIB_DIRS)
-        # Normalize the directory path
-        get_filename_component(NORMALIZED_DIR "${DIR}" ABSOLUTE)
-        
-        # Debugging message to verify the directory being checked
-        message(STATUS "Checking directory: ${NORMALIZED_DIR}")
-        
         # Ensure directory structure is as expected
-        message(STATUS "Checking if ${NORMALIZED_DIR}/src exists")
-        if(NOT IS_DIRECTORY "${NORMALIZED_DIR}/src")
-        message(FATAL_ERROR "Directory for ${LIB_NAME} does not have the expected 'src' structure: ${NORMALIZED_DIR}/src")
-        endif()
-        message(STATUS "Checking if ${NORMALIZED_DIR}/include exists")
-        if(NOT IS_DIRECTORY "${NORMALIZED_DIR}/include")
-            message(FATAL_ERROR "Directory for ${LIB_NAME} does not have the expected 'include' structure: ${NORMALIZED_DIR}/include")
+        if(NOT EXISTS "${DIR}/src" OR NOT EXISTS "${DIR}/include")
+            message(FATAL_ERROR "Directory for ${LIB_NAME} does not have the expected 'src' or 'include' structure: ${DIR}")
         endif()
 
         # Glob for source files in each provided directory.
-        file(GLOB_RECURSE TEMP_SOURCES "${NORMALIZED_DIR}/src/*.c")
+        file(GLOB_RECURSE TEMP_SOURCES "${DIR}/src/*.c")
         list(APPEND LIB_SOURCES ${TEMP_SOURCES})
 
         # Collect include directories
-        list(APPEND LIB_INCLUDE_DIRS "${NORMALIZED_DIR}/include")
+        list(APPEND LIB_INCLUDE_DIRS "${DIR}/include")
     endforeach()
     
     if(LIB_SOURCES)
diff --git a/cmake/options/set_default_debug_options.cmake b/cmake/options/set_default_debug_options.cmake
index 23f00b6..5a7af80 100644
--- a/cmake/options/set_default_debug_options.cmake
+++ b/cmake/options/set_default_debug_options.cmake
@@ -6,7 +6,7 @@
 # -----------------------------------------------------------------------------
 
 # Adds an option to CMake to control the use of Address Sanitizer
-option(USE_ADDRESS_SANITIZER "Use Address Sanitizer for Debug Builds" ON)
+option(USE_ADDRESS_SANITIZER "Use Address Sanitizer for Debug Builds" OFF)
 
 function(set_default_debug_options)
     # Common compiler options
diff --git a/cmake/targets/add_all_targets.cmake b/cmake/targets/add_all_targets.cmake
index 4440036..da0db1a 100644
--- a/cmake/targets/add_all_targets.cmake
+++ b/cmake/targets/add_all_targets.cmake
@@ -9,7 +9,6 @@ function(add_all_targets)
 
     add_local_executables()
     add_remote_executables()
-    add_pointer_demos()
 
 endfunction()
 
@@ -29,12 +28,12 @@ function(add_remote_executables)
 
     add_target(
     #   [ FIELD ]-----------[ VALUE ]
-        TARGET_NAME         lights_server
+        TARGET_NAME         poll_server
         ENDPOINT            remote
         TARGET_TYPE         EXE
         SOURCE_DIR          projects
         DESTINATION_DIR     projects
-        LIBRARIES           Common Math DSA Threading Networking bcm2835
+        LIBRARIES           Common Math DSA Threading Networking
     )
 
 endfunction()
@@ -48,9 +47,9 @@ function(add_pointer_demos)
     add_target(
     #   [ FIELD ]-----------[ VALUE ]
         TARGET_NAME         demo_1_basic_pointer_usage
-        ENDPOINT            local
+        ENDPOINT            LOCAL
         TARGET_TYPE         EXE
-        SOURCE_DIR          training/pointers/demos/1_basic_pointer_usage/
+        SOURCE_DIR          training/pointers/demos/1_basic_pointer_usage
         DESTINATION_DIR     training/pointers/demos
         LIBRARIES           Common
     )
@@ -58,7 +57,7 @@ function(add_pointer_demos)
     add_target(
     #   [ FIELD ]-----------[ VALUE ]
         TARGET_NAME         demo_2_pointer_and_array
-        ENDPOINT            local
+        ENDPOINT            LOCAL
         TARGET_TYPE         EXE
         SOURCE_DIR          training/pointers/demos/2_pointer_and_array
         DESTINATION_DIR     training/pointers/demos
@@ -68,7 +67,7 @@ function(add_pointer_demos)
     add_target(
     #   [ FIELD ]-----------[ VALUE ]
         TARGET_NAME         demo_3_passing_pointers
-        ENDPOINT            local
+        ENDPOINT            LOCAL
         TARGET_TYPE         EXE
         SOURCE_DIR          training/pointers/demos/3_passing_pointers_to_functions
         DESTINATION_DIR     training/pointers/demos
@@ -78,7 +77,7 @@ function(add_pointer_demos)
     add_target(
     #   [ FIELD ]-----------[ VALUE ]
         TARGET_NAME         demo_4_dynamic_memory_allocation
-        ENDPOINT            local
+        ENDPOINT            LOCAL
         TARGET_TYPE         EXE
         SOURCE_DIR          training/pointers/demos/4_dynamic_memory_allocation
         DESTINATION_DIR     training/pointers/demos
diff --git a/cmake/testing/add_all_tests.cmake b/cmake/testing/add_all_tests.cmake
index 060b9a0..467071a 100644
--- a/cmake/testing/add_all_tests.cmake
+++ b/cmake/testing/add_all_tests.cmake
@@ -7,7 +7,6 @@
 function(add_all_tests)
 
     library_tests()
-    training_tests()
 
 endfunction()
 
@@ -21,14 +20,6 @@ function(library_tests)
         ADDITIONAL_LIBRARIES    Common # Specify additional libraries as needed
     )
 
-    add_cunit_test(
-        TARGET_NAME             test_queue
-        PROJECT_DIRECTORY       ${CMAKE_SOURCE_DIR}/libraries/DSA/queue
-        TEST_DIRECTORY          ${CMAKE_SOURCE_DIR}/libraries/DSA/queue/tests
-        OUTPUT_DIRECTORY        ${CMAKE_SYSTEM_PROCESSOR}/tests/library_tests/${CMAKE_BUILD_TYPE}/DSA
-        ADDITIONAL_LIBRARIES    Common # Specify additional libraries as needed
-    )
-
     add_cunit_test(
         TARGET_NAME             test_linked_list
         PROJECT_DIRECTORY       ${CMAKE_SOURCE_DIR}/libraries/DSA/linked_list
@@ -37,14 +28,6 @@ function(library_tests)
         ADDITIONAL_LIBRARIES    Common Math# Specify additional libraries as needed
     )
 
-    add_cunit_test(
-        TARGET_NAME             test_adjacency_list
-        PROJECT_DIRECTORY       ${CMAKE_SOURCE_DIR}/libraries/DSA/adjacency_list
-        TEST_DIRECTORY          ${CMAKE_SOURCE_DIR}/libraries/DSA/adjacency_list/tests
-        OUTPUT_DIRECTORY        ${CMAKE_SYSTEM_PROCESSOR}/tests/library_tests/${CMAKE_BUILD_TYPE}/DSA
-        ADDITIONAL_LIBRARIES    Common Math DSA# Specify additional libraries as needed
-    )
-
 endfunction()
 
 function(training_tests)
diff --git a/cmake/toolchains/aarch64-glibc-toolchain.cmake b/cmake/toolchains/aarch64-glibc-toolchain.cmake
index 2108bb8..c92cb58 100644
--- a/cmake/toolchains/aarch64-glibc-toolchain.cmake
+++ b/cmake/toolchains/aarch64-glibc-toolchain.cmake
@@ -10,7 +10,7 @@
 
 set(CMAKE_SYSTEM_NAME Linux)
 set(CMAKE_SYSTEM_PROCESSOR aarch64)
-set(tools /opt/aarch64--glibc--stable-2022.08-1)
+set(tools /opt/aarch64--glibc--stable-2024.02-1)
 set(CMAKE_C_COMPILER ${tools}/bin/aarch64-linux-gcc)
 set(CMAKE_CXX_COMPILER ${tools}/bin/aarch64-linux-g++)
 set(CMAKE_FIND_ROOT_PATH ${tools})
diff --git a/docs/cross_compilation/1_cross_compilation_setup_aarch64.md b/docs/cross_compilation/1_cross_compilation_setup_aarch64.md
index c6a0e41..671cdbd 100644
--- a/docs/cross_compilation/1_cross_compilation_setup_aarch64.md
+++ b/docs/cross_compilation/1_cross_compilation_setup_aarch64.md
@@ -17,7 +17,7 @@ Before starting, ensure you have CMake and Make installed on your development ma
 2. Move the extracted folder to the `/opt` directory. This location is typical for toolchains and external libraries, ensuring system-wide accessibility.
 
    ```bash
-   sudo mv <your-extracted-folder> /opt/aarch64--glibc--stable-2024.05-1 # Change this to whatever version you are installing
+   sudo mv <your-extracted-folder> /opt/aarch64--glibc--stable-2024.02-1
    ```
 
 ## Step 3: Project Directory Structure
@@ -52,7 +52,7 @@ Ensure your main project directory is organized as follows, which is a common st
 
 set(CMAKE_SYSTEM_NAME Linux)
 set(CMAKE_SYSTEM_PROCESSOR aarch64)
-set(tools /opt/aarch64--glibc--stable-2024.05-1) # Change this to whatever version you are installing
+set(tools /opt/aarch64--glibc--stable-2024.02-1)
 set(CMAKE_C_COMPILER ${tools}/bin/aarch64-linux-gcc)
 set(CMAKE_CXX_COMPILER ${tools}/bin/aarch64-linux-g++)
 set(CMAKE_FIND_ROOT_PATH ${tools})
@@ -90,7 +90,7 @@ AARCH64_TOOLCHAIN = cmake/toolchains/aarch64-glibc-toolchain.cmake
 
 default: release
 
-all:
+all: 
 	@$(MAKE) release
 	@$(MAKE) debug
 	@$(MAKE) aarch64
@@ -125,4 +125,4 @@ clean:
 
 ## Conclusion
 
-You've now set up your environment for cross-compiling projects using CMake and Make for the AARCH64 architecture. This setup provides a flexible foundation for developing applications across different platforms from a single codebase. Remember to adjust the paths and toolchain versions according to your specific project requirements and toolchain updates.
+You've now set up your environment for cross-compiling projects using CMake and Make for the AARCH64 architecture. This setup provides a flexible foundation for developing applications across different platforms from a single codebase. Remember to adjust the paths and toolchain versions according to your specific project requirements and toolchain updates.
\ No newline at end of file
diff --git a/docs/cross_compilation/2_aarch64_cunit_guide.md b/docs/cross_compilation/2_aarch64_cunit_guide.md
index 0d2662e..5e726a9 100644
--- a/docs/cross_compilation/2_aarch64_cunit_guide.md
+++ b/docs/cross_compilation/2_aarch64_cunit_guide.md
@@ -41,16 +41,16 @@ Run the `bootstrap` script to prepare the build configuration:
 
 ### 4. Set Environment Variables for Cross-Compilation
 
-Set the environment variables to point to your aarch64 toolchain. Adjust the paths according to the location of your toolchain. For example, if you have the `glibc 2024.05-1` version installed in the `/opt/` directory:
+Set the environment variables to point to your aarch64 toolchain. Adjust the paths according to the location of your toolchain. For example, if you have the `glibc 2024.02-1` version installed in the `/opt/` directory:
 
 ```bash
-export CC=/opt/aarch64--glibc--stable-2024.05-1/bin/aarch64-linux-gcc
-export CXX=/opt/aarch64--glibc--stable-2024.05-1/bin/aarch64-linux-g++
-export AR=/opt/aarch64--glibc--stable-2024.05-1/bin/aarch64-linux-ar
-export AS=/opt/aarch64--glibc--stable-2024.05-1/bin/aarch64-linux-as
-export LD=/opt/aarch64--glibc--stable-2024.05-1/bin/aarch64-linux-ld
-export RANLIB=/opt/aarch64--glibc--stable-2024.05-1/bin/aarch64-linux-ranlib
-export PKG_CONFIG_PATH=/opt/aarch64--glibc--stable-2024.05-1/aarch64-buildroot-linux-gnu/sysroot/usr/lib/pkgconfig
+export CC=/opt/aarch64--glibc--stable-2024.02-1/bin/aarch64-linux-gcc
+export CXX=/opt/aarch64--glibc--stable-2024.02-1/bin/aarch64-linux-g++
+export AR=/opt/aarch64--glibc--stable-2024.02-1/bin/aarch64-linux-ar
+export AS=/opt/aarch64--glibc--stable-2024.02-1/bin/aarch64-linux-as
+export LD=/opt/aarch64--glibc--stable-2024.02-1/bin/aarch64-linux-ld
+export RANLIB=/opt/aarch64--glibc--stable-2024.02-1/bin/aarch64-linux-ranlib
+export PKG_CONFIG_PATH=/opt/aarch64--glibc--stable-2024.02-1/aarch64-buildroot-linux-gnu/sysroot/usr/lib/pkgconfig
 ```
 
 ### 5. Configure CUnit for Cross-Compilation
@@ -58,7 +58,7 @@ export PKG_CONFIG_PATH=/opt/aarch64--glibc--stable-2024.05-1/aarch64-buildroot-l
 Configure CUnit with the correct `--host` and `--prefix` options to match your target architecture and the location of your toolchain:
 
 ```bash
-./configure --host=aarch64-linux-gnu --prefix=/opt/aarch64--glibc--stable-2024.05-1/aarch64-buildroot-linux-gnu/sysroot/usr
+./configure --host=aarch64-linux-gnu --prefix=/opt/aarch64--glibc--stable-2024.02-1/aarch64-buildroot-linux-gnu/sysroot/usr
 ```
 
 ### 6. Compile and Install CUnit
diff --git a/libraries/Common/include/callback_types.h b/libraries/Common/include/callback_types.h
deleted file mode 100644
index e101a59..0000000
--- a/libraries/Common/include/callback_types.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * @file callback_types.h
- *
- * @brief
- */
-#ifndef _CALLBACK_TYPES_H
-#define _CALLBACK_TYPES_H
-
-#include "comparisons.h"
-
-/**
- * @brief Function pointer type for custom free functions.
- */
-typedef void (*FREE_F)(void *);
-
-/**
- * @brief Function pointer type for custom action functions.
- */
-typedef void (*ACTION_F)(const void *);
-
-/**
- * @brief Function pointer type for custom compare functions.
- */
-typedef comp_rtns_t (*CMP_F)(void *, void *);
-
-#endif /* _CALLBACK_TYPES_H */
-
-/*** end of file ***/
diff --git a/libraries/Common/include/comparisons.h b/libraries/Common/include/comparisons.h
index e91a9bb..9f6f8d9 100644
--- a/libraries/Common/include/comparisons.h
+++ b/libraries/Common/include/comparisons.h
@@ -7,7 +7,7 @@
 
 // return values all comparison functions should use for standardizing
 // behavior
-typedef enum
+typedef enum comp_rtns
 {
     ERROR = -1,
     EQUAL,
@@ -17,16 +17,11 @@ typedef enum
 } comp_rtns_t;
 
 /**
- * @brief Compare function for node pointers.
+ * @brief A pointer to a user-defined function for comparing data in void
+ * sources
  *
- * Compares two node pointers for equality. Returns EQUAL if the pointers are
- * the same, and NOT_EQUAL otherwise.
- *
- * @param ptr_1 Pointer to the first node.
- * @param ptr_2 Pointer to the second node.
- * @return EQUAL if the pointers are the same, NOT_EQUAL otherwise.
  */
-comp_rtns_t node_ptr_comp(void * ptr_1, void * ptr_2);
+typedef comp_rtns_t (*CMP_F)(void *, void *);
 
 /**
  * @brief Fuction to compare integer data inside two void sources
diff --git a/libraries/Common/include/system_info.h b/libraries/Common/include/system_info.h
deleted file mode 100644
index 585d76a..0000000
--- a/libraries/Common/include/system_info.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * @file system_info.h
- *
- * @brief
- */
-#ifndef _SYSTEM_INFO_H
-#define _SYSTEM_INFO_H
-
-#include <stdio.h>
-#include <stdlib.h>
-
-char * get_hostname();
-char * get_operating_system();
-char * get_cpu_info();
-char * get_cpu_architecture();
-char * get_memory_info();
-char * get_network_interfaces();
-
-#endif /* _SYSTEM_INFO_H */
-
-/*** end of file ***/
diff --git a/libraries/Common/include/utilities.h b/libraries/Common/include/utilities.h
index aa75013..1df66cb 100644
--- a/libraries/Common/include/utilities.h
+++ b/libraries/Common/include/utilities.h
@@ -110,10 +110,6 @@ int message_log(const char * prefix_p,
                 const char * format,
                 ...);
 
-int log_system_info();
-
-void noop_free(void * data);
-
 #endif /* _UTILITIES_H */
 
 /*** end of file ***/
diff --git a/libraries/Common/src/comparisons.c b/libraries/Common/src/comparisons.c
index e8563a0..99b5679 100644
--- a/libraries/Common/src/comparisons.c
+++ b/libraries/Common/src/comparisons.c
@@ -11,27 +11,6 @@ typedef struct
     int col;
 } cell_t;
 
-comp_rtns_t node_ptr_comp(void * ptr_1, void * ptr_2)
-{
-    comp_rtns_t result = ERROR;
-
-    if ((NULL == ptr_1) || (NULL == ptr_2))
-    {
-        print_error("node_ptr_comp(): NULL argument passed.");
-        goto END;
-    }
-
-    if (ptr_1 == ptr_2)
-    {
-        result = EQUAL;
-    }
-
-    result = NOT_EQUAL;
-
-END:
-    return result;
-}
-
 comp_rtns_t int_comp(void * p_node_one_data, void * p_node_two_data)
 {
     comp_rtns_t result   = ERROR;
diff --git a/libraries/Common/src/system_info.c b/libraries/Common/src/system_info.c
deleted file mode 100644
index 7f3cacd..0000000
--- a/libraries/Common/src/system_info.c
+++ /dev/null
@@ -1,204 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/utsname.h>
-#include <unistd.h>
-
-#include "system_info.h"
-
-#define BUFFER_SIZE 1024
-
-char * get_hostname()
-{
-    char   hostname[BUFFER_SIZE];
-    char * result = (char *)malloc(BUFFER_SIZE);
-    if (result == NULL)
-    {
-        perror("malloc");
-        return NULL;
-    }
-
-    if (gethostname(hostname, sizeof(hostname)) == 0)
-    {
-        snprintf(result, BUFFER_SIZE, "%s", hostname);
-    }
-    else
-    {
-        perror("gethostname");
-        free(result);
-        return NULL;
-    }
-    return result;
-}
-
-char * get_operating_system()
-{
-    FILE * os_release = fopen("/etc/os-release", "r");
-    char   buffer[BUFFER_SIZE];
-    char * result = (char *)malloc(BUFFER_SIZE);
-    if (result == NULL)
-    {
-        perror("malloc");
-        return NULL;
-    }
-
-    if (os_release != NULL)
-    {
-        while (fgets(buffer, sizeof(buffer), os_release) != NULL)
-        {
-            if (strncmp(buffer, "PRETTY_NAME=", 12) == 0)
-            {
-                char * name = strchr(buffer, '"');
-                if (name != NULL)
-                {
-                    name++;
-                    char * end = strchr(name, '"');
-                    if (end != NULL)
-                    {
-                        *end = '\0';
-                        snprintf(result, BUFFER_SIZE, "%s", name);
-                        fclose(os_release);
-                        return result;
-                    }
-                }
-            }
-        }
-        fclose(os_release);
-    }
-
-    perror("fopen");
-    free(result);
-    return NULL;
-}
-
-char * get_cpu_info()
-{
-    FILE * cpuinfo = fopen("/proc/cpuinfo", "r");
-    char   buffer[BUFFER_SIZE];
-    char * result = (char *)malloc(BUFFER_SIZE);
-    if (result == NULL)
-    {
-        perror("malloc");
-        return NULL;
-    }
-
-    if (cpuinfo != NULL)
-    {
-        while (fgets(buffer, sizeof(buffer), cpuinfo) != NULL)
-        {
-            if (strncmp(buffer, "model name", 10) == 0)
-            {
-                // Remove newline character from the buffer if present
-                char * newline = strchr(buffer, '\n');
-                if (newline)
-                {
-                    *newline = '\0';
-                }
-
-                snprintf(result, BUFFER_SIZE, "%s", strchr(buffer, ':') + 2);
-                fclose(cpuinfo);
-                return result;
-            }
-        }
-        fclose(cpuinfo);
-    }
-
-    perror("fopen");
-    free(result);
-    return NULL;
-}
-
-char * get_cpu_architecture()
-{
-    struct utsname buffer;
-    char *         result = (char *)malloc(BUFFER_SIZE);
-    if (result == NULL)
-    {
-        perror("malloc");
-        return NULL;
-    }
-
-    if (uname(&buffer) == 0)
-    {
-        snprintf(result, BUFFER_SIZE, "%s", buffer.machine);
-    }
-    else
-    {
-        perror("uname");
-        free(result);
-        return NULL;
-    }
-    return result;
-}
-
-char * get_memory_info()
-{
-    FILE * meminfo = fopen("/proc/meminfo", "r");
-    char   buffer[BUFFER_SIZE];
-    char * result = (char *)malloc(BUFFER_SIZE);
-    if (result == NULL)
-    {
-        perror("malloc");
-        return NULL;
-    }
-
-    if (meminfo != NULL)
-    {
-        while (fgets(buffer, sizeof(buffer), meminfo) != NULL)
-        {
-            if (strncmp(buffer, "MemTotal", 8) == 0)
-            {
-                char * mem_kb_str = strchr(buffer, ':') + 1;
-                long   mem_kb     = strtol(mem_kb_str, NULL, 10);
-                long   mem_mb     = mem_kb / 1024;
-                snprintf(result, BUFFER_SIZE, "%ld MB", mem_mb);
-                fclose(meminfo);
-                return result;
-            }
-        }
-        fclose(meminfo);
-    }
-
-    perror("fopen");
-    free(result);
-    return NULL;
-}
-
-char * get_network_interfaces()
-{
-    FILE * netdev = fopen("/proc/net/dev", "r");
-    char   buffer[BUFFER_SIZE];
-    char * result = (char *)malloc(BUFFER_SIZE);
-    if (result == NULL)
-    {
-        perror("malloc");
-        return NULL;
-    }
-
-    if (netdev != NULL)
-    {
-        // Skip the first two lines of headers
-        fgets(buffer, sizeof(buffer), netdev);
-        fgets(buffer, sizeof(buffer), netdev);
-
-        snprintf(result, BUFFER_SIZE, "Network Interfaces:\n");
-        char * result_ptr = result + strlen(result);
-
-        while (fgets(buffer, sizeof(buffer), netdev) != NULL)
-        {
-            char * interface = strtok(buffer, " :");
-            result_ptr += snprintf(result_ptr,
-                                   BUFFER_SIZE - (result_ptr - result),
-                                   "  %s\n",
-                                   interface);
-        }
-        fclose(netdev);
-    }
-    else
-    {
-        perror("fopen");
-        free(result);
-        return NULL;
-    }
-    return result;
-}
\ No newline at end of file
diff --git a/libraries/Common/src/utilities.c b/libraries/Common/src/utilities.c
index 2fd8dbb..7595f95 100644
--- a/libraries/Common/src/utilities.c
+++ b/libraries/Common/src/utilities.c
@@ -7,12 +7,10 @@
 #include <string.h>
 #include <time.h>
 
-#include "system_info.h"
 #include "utilities.h"
 
 #define BYTE             8
 #define TIME_BUFFER_SIZE 80
-#define BUFFER_SIZE      1024
 
 void print_error(const char * p_message)
 {
@@ -48,125 +46,6 @@ END:
     return;
 }
 
-void print_boxed_info(FILE *       output,
-                      const char * header,
-                      const char * hostname,
-                      const char * os,
-                      const char * cpu,
-                      const char * architecture,
-                      const char * memory)
-{
-    size_t max_len = strlen(header);
-
-    // Calculate the max length considering the full strings
-    char temp[BUFFER_SIZE];
-    snprintf(temp, BUFFER_SIZE, "Hostname: %s", hostname);
-    max_len = max_len > strlen(temp) ? max_len : strlen(temp);
-
-    snprintf(temp, BUFFER_SIZE, "Operating System: %s", os);
-    max_len = max_len > strlen(temp) ? max_len : strlen(temp);
-
-    snprintf(temp, BUFFER_SIZE, "CPU: %s", cpu);
-    max_len = max_len > strlen(temp) ? max_len : strlen(temp);
-
-    snprintf(temp, BUFFER_SIZE, "Architecture: %s", architecture);
-    max_len = max_len > strlen(temp) ? max_len : strlen(temp);
-
-    snprintf(temp, BUFFER_SIZE, "Memory: %s", memory);
-    max_len = max_len > strlen(temp) ? max_len : strlen(temp);
-
-    max_len += 2; // Padding
-
-    fprintf(output, "+");
-    for (size_t i = 0; i < max_len + 2; i++)
-    {
-        fprintf(output, "-");
-    }
-    fprintf(output, "+\n");
-
-    fprintf(output, "| %-*s |\n", (int)max_len, header);
-
-    fprintf(output, "+");
-    for (size_t i = 0; i < max_len + 2; i++)
-    {
-        fprintf(output, "-");
-    }
-    fprintf(output, "+\n");
-
-    snprintf(temp, BUFFER_SIZE, "Hostname: %s", hostname);
-    fprintf(output, "| %-*s |\n", (int)max_len, temp);
-
-    snprintf(temp, BUFFER_SIZE, "Operating System: %s", os);
-    fprintf(output, "| %-*s |\n", (int)max_len, temp);
-
-    snprintf(temp, BUFFER_SIZE, "CPU: %s", cpu);
-    fprintf(output, "| %-*s |\n", (int)max_len, temp);
-
-    snprintf(temp, BUFFER_SIZE, "Architecture: %s", architecture);
-    fprintf(output, "| %-*s |\n", (int)max_len, temp);
-
-    snprintf(temp, BUFFER_SIZE, "Memory: %s", memory);
-    fprintf(output, "| %-*s |\n", (int)max_len, temp);
-
-    fprintf(output, "+");
-    for (size_t i = 0; i < max_len + 2; i++)
-    {
-        fprintf(output, "-");
-    }
-    fprintf(output, "+\n");
-}
-
-int log_system_info()
-{
-    int    exit_code = E_FAILURE;
-    FILE * file      = NULL;
-    char * hostname  = NULL;
-    char * os        = NULL;
-    char * cpu       = NULL;
-    char * arch      = NULL;
-    char * memory    = NULL;
-
-    hostname = get_hostname();
-    os       = get_operating_system();
-    cpu      = get_cpu_info();
-    arch     = get_cpu_architecture();
-    memory   = get_memory_info();
-
-    file = fopen(LOGFILE, "a");
-    if (!file)
-    {
-        fprintf(stderr, "log_system_info(): Unable to open log file.\n");
-        goto END;
-    }
-
-    print_boxed_info(file,
-                     "SYSTEM INFO",
-                     hostname ? hostname : "N/A",
-                     os ? os : "N/A",
-                     cpu ? cpu : "N/A",
-                     arch ? arch : "N/A",
-                     memory ? memory : "N/A");
-    fclose(file);
-
-    print_boxed_info(stdout,
-                     "SYSTEM INFO",
-                     hostname ? hostname : "N/A",
-                     os ? os : "N/A",
-                     cpu ? cpu : "N/A",
-                     arch ? arch : "N/A",
-                     memory ? memory : "N/A");
-
-    exit_code = E_SUCCESS;
-
-END:
-    free(hostname);
-    free(os);
-    free(cpu);
-    free(arch);
-    free(memory);
-    return exit_code;
-}
-
 int message_log(const char * prefix_p,
                 color_code_t color,
                 log_dest_t   destination,
@@ -244,16 +123,6 @@ int message_log(const char * prefix_p,
         }
     }
 
-    if (0 == strncmp(prefix_p, "SESSION_START", 25))
-    {
-        fprintf(file,
-                "\n---------------------------------SESSION "
-                "START---------------------------------\n\n");
-        fclose(file);
-        exit_code = E_SUCCESS;
-        goto END;
-    }
-
     // Print the message with timestamp
     if (destination == LOG_CONSOLE || destination == LOG_BOTH)
     {
@@ -275,10 +144,4 @@ END:
     return exit_code;
 }
 
-void noop_free(void * data)
-{
-    // No operation
-    (void)data;
-}
-
 /*** end of file ***/
diff --git a/libraries/DSA/adjacency_list/include/adjacency_list.h b/libraries/DSA/adjacency_list/include/adjacency_list.h
index e035077..68592d2 100644
--- a/libraries/DSA/adjacency_list/include/adjacency_list.h
+++ b/libraries/DSA/adjacency_list/include/adjacency_list.h
@@ -1,258 +1,181 @@
+/**
+ * @file adjacency_list.h
+ *
+ * @brief
+ */
 #ifndef _ADJACENCY_LIST_H
 #define _ADJACENCY_LIST_H
 
 #include <stdbool.h>
 #include <stdint.h>
 
-#include "callback_types.h"
 #include "linked_list.h"
 
 /**
- * @brief Structure representing a node in the graph.
- */
-typedef struct
-{
-    void *   data;       // Pointer to the data stored in the node
-    size_t   edge_count; // Number of edges connected to the node
-    list_t * edge_list;  // List of edges connected to the node
-} node_t;
-
-/**
- * @brief Structure representing an edge in the graph.
- */
-typedef struct
-{
-    node_t * node_1;      // Pointer to the first node of the edge
-    node_t * node_2;      // Pointer to the second node of the edge
-    size_t   weight;      // Weight of the edge
-    bool     is_directed; // Flag indicating if the edge is directed
-} edge_t;
-
-/**
- * @brief Structure representing a graph.
- */
-typedef struct
-{
-    size_t   node_count;     // Number of nodes in the graph
-    list_t * node_list;      // List of nodes in the graph
-    FREE_F   custom_free;    // Custom free function
-    CMP_F    custom_compare; // Custom compare function
-} graph_t;
-
-/**
- * @brief Creates a new graph.
+ * @brief A function pointer type for custom free operations on graph data.
  *
- * @param custom_free Function pointer to the custom free function.
- * @param custom_compare Function pointer to the custom compare function.
- * @return Pointer to the newly created graph, or NULL on failure.
+ * @param data_p A pointer to the data to be freed.
  */
-graph_t * graph_create(FREE_F custom_free, CMP_F custom_compare);
+typedef void (*FREE_F)(void *);
 
 /**
- * @brief Adds a node to the graph.
+ * @brief A function pointer type for custom print operations on graph data.
  *
- * @param graph Pointer to the graph.
- * @param data Pointer to the data to be added.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param data_p A pointer to the data to print.
  */
-int graph_add_node(graph_t * graph, void * data);
+typedef void (*PRINT_F)(const void *);
 
 /**
- * @brief Removes a node from the graph.
+ * @brief Represents a node in the graph.
  *
- * @param graph Pointer to the graph.
- * @param data Pointer to the data of the node to be removed.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * A node contains user-defined data, a count of its outgoing/incoming edges,
+ * and a pointer to a list of its edges.
  */
-int graph_remove_node(graph_t * graph, void * data);
-
-/**
- * @brief Adds an edge between two nodes in the graph.
- *
- * @param graph Pointer to the graph.
- * @param data_1 Pointer to the data of the first node.
- * @param data_2 Pointer to the data of the second node.
- * @param weight Weight of the edge.
- * @param is_bidirectional Flag indicating if the edge is bidirectional.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
- */
-int graph_add_edge(graph_t * graph,
-                   void *    data_1,
-                   void *    data_2,
-                   size_t    weight,
-                   bool      is_bidirectional);
-
-/**
- * @brief Removes an edge between two nodes in the graph.
- *
- * @param graph Pointer to the graph.
- * @param data_1 Pointer to the data of the first node.
- * @param data_2 Pointer to the data of the second node.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
- */
-int graph_remove_edge(graph_t * graph, void * data_1, void * data_2);
-
-/**
- * @brief Gets the size of the graph.
- *
- * @param graph Pointer to the graph.
- * @return Size of the graph (number of nodes).
- */
-size_t graph_get_size(graph_t * graph);
-
-/**
- * @brief Prints the graph using a custom print function.
- *
- * @param graph Pointer to the graph.
- * @param custom_print Function pointer to the custom print function.
- */
-void graph_print(graph_t * graph, ACTION_F custom_print);
-
-/**
- * @brief Clears all nodes and edges from the graph.
- *
- * @param graph Pointer to the graph.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
- */
-int graph_clear(graph_t * graph);
+typedef struct
+{
+    void *   data_p;      /**< Pointer to the data for this node. */
+    size_t   edge_count;  /**< The number of edges connected to this node. */
+    list_t * edge_list_p; /**< Pointer to a list of edges for this node. */
+} node_t;
 
 /**
- * @brief Destroys the graph and frees all associated memory.
+ * @brief Represents an edge in the graph.
  *
- * @param graph Pointer to the pointer to the graph.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * An edge connects two nodes, has an associated weight, and can be directed or
+ * undirected.
  */
-int graph_destroy(graph_t ** graph);
+typedef struct
+{
+    node_t * node_1_p;    /**< Pointer to the first node in the edge. */
+    node_t * node_2_p;    /**< Pointer to the second node in the edge. */
+    size_t   weight;      /**< Weight of the edge. */
+    bool     is_directed; /**< Flag indicating if the edge is directed. */
+} edge_t;
 
 /**
- * @brief Performs depth-first search (DFS) on the graph.
+ * @brief Represents a graph structure.
  *
- * @param graph Pointer to the graph.
- * @param start_data Pointer to the data of the starting node.
- * @param action Function pointer to the custom action function.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * A graph contains a count of its nodes, a pointer to a list of its nodes, and
+ * function pointers for custom free and compare operations.
  */
-int graph_dfs(graph_t * graph, void * start_data, ACTION_F action);
+typedef struct
+{
+    size_t   node_count;  /**< The number of nodes in the graph. */
+    list_t * node_list_p; /**< Pointer to a list containing all nodes in the
+                             graph. */
+    FREE_F custom_free;   /**< Function pointer for custom free operation on
+                             graph's nodes. */
+    CMP_F custom_compare; /**< Function pointer for custom comparison operation
+                             on graph's nodes. */
+} graph_t;
 
 /**
- * @brief Performs breadth-first search (BFS) on the graph.
+ * @brief Creates a new graph.
  *
- * @param graph Pointer to the graph.
- * @param start_data Pointer to the data of the starting node.
- * @param action Function pointer to the custom action function.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param custom_free A function pointer for custom free operation.
+ * @param custom_compare A function pointer for custom comparison operation.
+ * @return graph_t* A pointer to the newly created graph or NULL on failure.
  */
-int graph_bfs(graph_t * graph, void * start_data, ACTION_F action);
+graph_t * graph_create(FREE_F custom_free, CMP_F custom_compare);
 
 /**
- * @brief Finds the shortest path between two nodes using Dijkstra's algorithm.
+ * @brief Creates a new node with the given data.
  *
- * @param graph Pointer to the graph.
- * @param start_data Pointer to the data of the starting node.
- * @param end_data Pointer to the data of the ending node.
- * @param path Pointer to the list to store the path.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param data_p A pointer to the data to be stored in the node.
+ * @return node_t* A pointer to the newly created node or NULL on failure.
  */
-int graph_dijkstra(graph_t * graph,
-                   void *    start_data,
-                   void *    end_data,
-                   list_t ** path);
+node_t * graph_create_node(void * data_p);
 
 /**
- * @brief Finds the shortest path between two nodes using A* algorithm.
+ * @brief Adds a new node with the given data to the graph.
  *
- * @param graph Pointer to the graph.
- * @param start_data Pointer to the data of the starting node.
- * @param end_data Pointer to the data of the ending node.
- * @param path Pointer to the list to store the path.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param graph_p A pointer to the graph.
+ * @param data_p A pointer to the data to be added.
+ * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-int graph_a_star(graph_t * graph,
-                 void *    start_data,
-                 void *    end_data,
-                 list_t ** path);
+int graph_add_node(graph_t * graph_p, void * data_p);
 
 /**
- * @brief Computes the shortest paths between all pairs of nodes using
- * Floyd-Warshall algorithm.
+ * @brief Removes a node with the given data from the graph.
  *
- * @param graph Pointer to the graph.
- * @param distances Pointer to the 2D array to store the distances.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param graph_p A pointer to the graph.
+ * @param data_p A pointer to the data identifying the node to be removed.
+ * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-int graph_floyd_warshall(graph_t * graph, size_t *** distances);
+int graph_remove_node(graph_t * graph_p, void * data_p);
 
 /**
- * @brief Checks if the graph is connected.
+ * @brief Adds an edge between two nodes in the graph.
  *
- * @param graph Pointer to the graph.
- * @param is_connected Pointer to the boolean to store the result.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param graph_p A pointer to the graph.
+ * @param data_1_p A pointer to the data of the first node.
+ * @param data_2_p A pointer to the data of the second node.
+ * @param weight The weight of the edge.
+ * @param is_bidirectional A boolean indicating if the edge is bidirectional.
+ * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-int graph_is_connected(graph_t * graph, bool * is_connected);
+int graph_add_edge(graph_t * graph_p,
+                   void *    data_1_p,
+                   void *    data_2_p,
+                   size_t    weight,
+                   bool      is_bidirectional);
 
 /**
- * @brief Checks if the graph contains a cycle.
+ * @brief Removes an edge between two nodes in the graph.
  *
- * @param graph Pointer to the graph.
- * @param is_cyclic Pointer to the boolean to store the result.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param graph_p A pointer to the graph.
+ * @param data_1_p A pointer to the data of the first node.
+ * @param data_2_p A pointer to the data of the second node.
+ * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-int graph_is_cyclic(graph_t * graph, bool * is_cyclic);
+int graph_remove_edge(graph_t * graph_p, void * data_1_p, void * data_2_p);
 
 /**
- * @brief Finds the connected components in the graph.
+ * @brief Returns the number of nodes in the graph.
  *
- * @param graph Pointer to the graph.
- * @return Pointer to the list of connected components.
+ * @param graph_p A pointer to the graph.
+ * @return size_t The number of nodes in the graph.
  */
-list_t * graph_find_connected_components(graph_t * graph);
+size_t graph_get_size(graph_t * graph_p);
 
 /**
- * @brief Gets the degree of a node in the graph.
+ * @brief Finds a node in the graph with the given data.
  *
- * @param graph Pointer to the graph.
- * @param data Pointer to the data of the node.
- * @param degree Pointer to the size_t to store the degree.
- * @return E_SUCCESS on success, or E_FAILURE on failure.
+ * @param graph_p A pointer to the graph.
+ * @param data_p A pointer to the data of the node to find.
+ * @return node_t* A pointer to the found node or NULL if not found.
  */
-int graph_node_degree(graph_t * graph, void * data, size_t * degree);
+node_t * graph_find_node(graph_t * graph_p, void * data_p);
 
 /**
- * @brief Gets the adjacent nodes of a given node in the graph.
+ * @brief Finds an edge between two nodes in the graph.
  *
- * @param graph Pointer to the graph.
- * @param data Pointer to the data of the node.
- * @return Pointer to the list of adjacent nodes.
+ * @param graph_p A pointer to the graph.
+ * @param node_1_p A pointer to the first node.
+ * @param node_2_p A pointer to the second node.
+ * @return edge_t* A pointer to the found edge or NULL if not found.
  */
-list_t * graph_get_adjacent_nodes(graph_t * graph, void * data);
+edge_t * graph_find_edge(graph_t * graph_p,
+                         node_t *  node_1_p,
+                         node_t *  node_2_p);
 
-/**
- * @brief Checks if an edge exists between two nodes in the graph.
- *
- * @param graph Pointer to the graph.
- * @param data_1 Pointer to the data of the first node.
- * @param data_2 Pointer to the data of the second node.
- * @return true if the edge exists, false otherwise.
- */
-bool graph_edge_exists(graph_t * graph, void * data_1, void * data_2);
+void graph_print(graph_t * graph_p, PRINT_F custom_print);
 
 /**
- * @brief Gets the weight of an edge between two nodes in the graph.
+ * @brief Clears the graph, removing all nodes and edges.
  *
- * @param graph Pointer to the graph.
- * @param data_1 Pointer to the data of the first node.
- * @param data_2 Pointer to the data of the second node.
- * @return Weight of the edge.
+ * @param graph_p A pointer to the graph to clear.
+ * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-size_t graph_get_edge_weight(graph_t * graph, void * data_1, void * data_2);
+int graph_clear(graph_t * graph_p);
 
 /**
- * @brief Creates a clone of the graph.
+ * @brief Destroys the graph, freeing all resources.
  *
- * @param graph Pointer to the graph.
- * @return Pointer to the cloned graph.
+ * @param graph_pp A pointer to a pointer to the graph to be destroyed.
+ * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-graph_t * graph_clone(graph_t * graph);
-
+int graph_destroy(graph_t ** graph_pp);
 #endif /* _ADJACENCY_LIST_H */
+
+/*** end of file ***/
diff --git a/libraries/DSA/adjacency_list/src/adjacency_list.c b/libraries/DSA/adjacency_list/src/adjacency_list.c
index 2453c96..6d0b7b1 100644
--- a/libraries/DSA/adjacency_list/src/adjacency_list.c
+++ b/libraries/DSA/adjacency_list/src/adjacency_list.c
@@ -1,87 +1,36 @@
 #include "adjacency_list.h"
-#include "queue.h"
-#include "stack.h"
 #include "utilities.h"
 
-#define MAX_STACK_SIZE 2000
-
-void edge_list_free(void * data)
+void edge_list_free(void * data_p)
 {
-    (void)data;
+    (void)data_p;
     return;
 }
 
-comp_rtns_t edge_compare(void * a, void * b)
-{
-    const edge_t * edge_a = (const edge_t *)a;
-    const edge_t * edge_b = (const edge_t *)b;
-
-    if (edge_a->node_1 == edge_b->node_1 && edge_a->node_2 == edge_b->node_2)
-    {
-        return EQUAL;
-    }
-    else if (edge_a->node_1 == edge_b->node_2 &&
-             edge_a->node_2 == edge_b->node_1 && !edge_a->is_directed)
-    {
-        return EQUAL;
-    }
-
-    return NOT_EQUAL;
-}
-
-/**
- * @brief Creates a new node with the given data.
- *
- * @param data A pointer to the data to be stored in the node.
- * @return node_t* A pointer to the newly created node or NULL on failure.
- */
-static node_t * graph_create_node(void * data);
-
-/**
- * @brief Finds a node in the graph with the given data.
- *
- * @param graph A pointer to the graph.
- * @param data A pointer to the data of the node to find.
- * @return node_t* A pointer to the found node or NULL if not found.
- */
-static node_t * graph_find_node(graph_t * graph, void * data);
-
-/**
- * @brief Finds an edge between two nodes in the graph.
- *
- * @param graph A pointer to the graph.
- * @param node_1 A pointer to the first node.
- * @param node_2 A pointer to the second node.
- * @return edge_t* A pointer to the found edge or NULL if not found.
- */
-static edge_t * graph_find_edge(graph_t * graph,
-                                node_t *  node_1,
-                                node_t *  node_2);
-
 /**
  * @brief Collects all edges connected to a given node.
  *
  * This function is static and intended for internal use only.
  *
- * @param node A pointer to the node whose edges are to be collected.
+ * @param node_p A pointer to the node whose edges are to be collected.
  * @param num_edges A pointer to size_t to store the number of edges found.
  * @return edge_t** A pointer to an array of pointers to the collected edges.
  */
-static edge_t ** collect_edges(node_t * node, uint32_t * num_edges);
+static edge_t ** collect_edges(node_t * node_p, size_t * num_edges);
 
 /**
  * @brief Removes a set of edges from a graph.
  *
  * This function is static and intended for internal use only.
  *
- * @param graph A pointer to the graph from which edges are to be removed.
- * @param edges_to_remove A pointer to an array of pointers to edges to be
+ * @param graph_p A pointer to the graph from which edges are to be removed.
+ * @param edges_to_remove_pp A pointer to an array of pointers to edges to be
  * removed.
  * @param num_edges The number of edges to remove.
  * @return int An integer indicating success (E_SUCCESS) or failure (E_FAILURE).
  */
-static int remove_edges(graph_t * graph,
-                        edge_t ** edges_to_remove,
+static int remove_edges(graph_t * graph_p,
+                        edge_t ** edges_to_remove_pp,
                         size_t    num_edges);
 
 /**
@@ -89,14 +38,14 @@ static int remove_edges(graph_t * graph,
  *
  * This function is static and intended for internal use only.
  *
- * @param graph A pointer to the graph containing the node.
- * @param node A pointer to the node to clean up.
+ * @param graph_p A pointer to the graph containing the node.
+ * @param node_p A pointer to the node to clean up.
  */
-static void cleanup_node(graph_t * graph, node_t * node);
+static void cleanup_node(graph_t * graph_p, node_t * node_p);
 
 graph_t * graph_create(FREE_F custom_free, CMP_F custom_compare)
 {
-    graph_t * graph = NULL;
+    graph_t * graph_p = NULL;
 
     if ((NULL == custom_free) || (NULL == custom_compare))
     {
@@ -104,95 +53,126 @@ graph_t * graph_create(FREE_F custom_free, CMP_F custom_compare)
         goto END;
     }
 
-    graph = calloc(1, sizeof(graph_t));
-    if (NULL == graph)
+    graph_p = calloc(1, sizeof(graph_t));
+    if (NULL == graph_p)
     {
         print_error("graph_create(): CMR failure.");
         goto END;
     }
 
-    graph->node_count     = 0;
-    graph->custom_free    = custom_free;
-    graph->custom_compare = custom_compare;
-    graph->node_list      = list_new(graph->custom_free, graph->custom_compare);
-    if (NULL == graph->node_list)
+    graph_p->node_count     = 0;
+    graph_p->custom_free    = custom_free;
+    graph_p->custom_compare = custom_compare;
+    graph_p->node_list_p =
+        list_new(graph_p->custom_free, graph_p->custom_compare);
+    if (NULL == graph_p->node_list_p)
     {
         print_error("graph_add_node(): Unable to create node list.");
-        free(graph);
-        graph = NULL;
+        free(graph_p);
+        graph_p = NULL;
         goto END;
     }
 
 END:
-    return graph;
+    return graph_p;
 }
 
-int graph_add_node(graph_t * graph, void * data)
+node_t * graph_create_node(void * data_p)
+{
+    node_t * new_node_p = NULL;
+
+    if (NULL == data_p)
+    {
+        print_error("graph_create_node(): NULL data passed.");
+        goto END;
+    }
+
+    new_node_p = calloc(1, sizeof(node_t));
+    if (NULL == new_node_p)
+    {
+        print_error("graph_create_node(): CMR failure.");
+        goto END;
+    }
+
+    new_node_p->data_p      = data_p;
+    new_node_p->edge_count  = 0;
+    new_node_p->edge_list_p = list_new(edge_list_free, NULL);
+    if (NULL == new_node_p->edge_list_p)
+    {
+        print_error("graph_create_node(): CMR failure.");
+        goto END;
+    }
+
+END:
+    return new_node_p;
+}
+
+int graph_add_node(graph_t * graph_p, void * data_p)
 {
     int      exit_code = E_FAILURE;
-    node_t * node      = NULL;
+    node_t * node_p    = NULL;
 
-    if ((NULL == graph) || (NULL == data))
+    if ((NULL == graph_p) || (NULL == data_p))
     {
         print_error("graph_add_node(): NULL argument passed.");
         goto END;
     }
 
-    node = graph_create_node(data);
-    if (NULL == node)
+    node_p = graph_create_node(data_p);
+    if (NULL == node_p)
     {
         print_error("graph_add_node(): Unable to create node.");
         goto END;
     }
 
     // Add the new node to the list
-    exit_code = list_push_head(graph->node_list, node);
+    exit_code = list_push_head(graph_p->node_list_p, node_p);
     if (E_SUCCESS != exit_code)
     {
         print_error("graph_add_node(): Unable to add new node to the list.");
         goto END;
     }
 
-    graph->node_count += 1;
+    graph_p->node_count += 1;
 
     exit_code = E_SUCCESS;
 END:
     if (E_SUCCESS != exit_code)
     {
-        free(node);
-        node = NULL;
+        free(node_p);
+        node_p = NULL;
     }
     return exit_code;
 }
 
-int graph_remove_node(graph_t * graph, void * data)
+int graph_remove_node(graph_t * graph_p, void * data_p)
 {
-    int       exit_code       = E_FAILURE;
-    node_t *  node            = NULL;
-    uint32_t  num_edges       = 0;
-    edge_t ** edges_to_remove = NULL;
+    int       exit_code          = E_FAILURE;
+    node_t *  node_p             = NULL;
+    size_t    num_edges          = 0;
+    edge_t ** edges_to_remove_pp = NULL;
 
-    if ((NULL == graph) || (NULL == data))
+    if ((NULL == graph_p) || (NULL == data_p))
     {
         print_error("graph_remove_node(): NULL argument passed.");
         goto END;
     }
 
-    node = graph_find_node(graph, data);
-    if (NULL == node)
+    node_p = graph_find_node(graph_p, data_p);
+    if (NULL == node_p)
     {
         print_error("graph_remove_node(): Unable to find node.");
         goto END;
     }
 
-    edges_to_remove = collect_edges(node, &num_edges);
-    if (NULL == edges_to_remove)
+    edges_to_remove_pp = collect_edges(node_p, &num_edges);
+    if (NULL == edges_to_remove_pp)
     {
         print_error("graph_remove_node(): Unable to collect edges.");
         goto END;
     }
 
-    exit_code = remove_edges(graph, edges_to_remove, num_edges);
+    exit_code = remove_edges(graph_p, edges_to_remove_pp, num_edges);
     if (E_SUCCESS != exit_code)
     {
         print_error("graph_remove_node(): Unable to remove edges.");
@@ -200,7 +180,7 @@ int graph_remove_node(graph_t * graph, void * data)
     }
 
     // Remove the node from the list of nodes
-    exit_code = list_remove_data(graph->node_list, &(node->data));
+    exit_code = list_remove_data(graph_p->node_list_p, node_p->data_p);
     if (E_SUCCESS != exit_code)
     {
         print_error(
@@ -208,127 +188,135 @@ int graph_remove_node(graph_t * graph, void * data)
         goto END;
     }
 
-    graph->node_count -= 1;
+    graph_p->node_count -= 1;
 
-    cleanup_node(graph, node);
+    cleanup_node(graph_p, node_p);
 
     exit_code = E_SUCCESS;
 END:
-    free(edges_to_remove);
-    edges_to_remove = NULL;
+    free(edges_to_remove_pp);
+    edges_to_remove_pp = NULL;
     return exit_code;
 }
 
-int graph_add_edge(graph_t * graph,
-                   void *    data_1,
-                   void *    data_2,
+int graph_add_edge(graph_t * graph_p,
+                   void *    data_1_p,
+                   void *    data_2_p,
                    size_t    weight,
                    bool      is_bidirectional)
 {
     int      exit_code = E_FAILURE;
-    node_t * node_1    = NULL;
-    node_t * node_2    = NULL;
-    edge_t * edge      = NULL;
+    node_t * node_1_p  = NULL;
+    node_t * node_2_p  = NULL;
+    edge_t * edge_p    = NULL;
 
-    if ((NULL == graph) || (NULL == data_1) || (NULL == data_2))
+    if ((NULL == graph_p) || (NULL == data_1_p) || (NULL == data_2_p))
     {
         print_error("graph_add_edge(): NULL argument passed.");
         goto END;
     }
 
-    node_1 = graph_find_node(graph, data_1);
-    if (NULL == node_1)
+    node_1_p = graph_find_node(graph_p, data_1_p);
+    if (NULL == node_1_p)
     {
         print_error("graph_add_edge(): Node 1 does not exist.");
         goto END;
     }
 
-    node_2 = graph_find_node(graph, data_2);
-    if (NULL == node_2)
+    node_2_p = graph_find_node(graph_p, data_2_p);
+    if (NULL == node_2_p)
     {
         print_error("graph_add_edge(): Node 2 does not exist.");
         goto END;
     }
 
-    edge = calloc(1, sizeof(edge_t));
-    if (NULL == edge)
+    edge_p = calloc(1, sizeof(edge_t));
+    if (NULL == edge_p)
     {
         print_error("graph_add_edge(): CMR failure.");
         goto END;
     }
 
-    edge->node_1      = node_1;
-    edge->node_2      = node_2;
-    edge->weight      = weight;
-    edge->is_directed = !is_bidirectional;
+    edge_p->node_1_p    = node_1_p;
+    edge_p->node_2_p    = node_2_p;
+    edge_p->weight      = weight;
+    edge_p->is_directed = !is_bidirectional;
 
-    exit_code = list_push_head(node_1->edge_list, edge);
+    exit_code = list_push_head(node_1_p->edge_list_p, edge_p);
     if (E_SUCCESS != exit_code)
     {
         print_error(
             "graph_add_edge(): Unable to add edge to node 1's edge list.");
-        free(edge);
         goto END;
     }
-    node_1->edge_count += 1;
+    node_1_p->edge_count += 1;
 
     if (true == is_bidirectional)
     {
-        exit_code = list_push_head(node_2->edge_list, edge);
+        exit_code = list_push_head(node_2_p->edge_list_p, edge_p);
         if (E_SUCCESS != exit_code)
         {
             print_error(
                 "graph_add_edge(): Unable to add edge to node 2's edge list.");
-            // Rollback
-            list_remove_data(node_1->edge_list, edge);
-            node_1->edge_count -= 1;
-            free(edge);
+            exit_code = list_remove_data(node_1_p->edge_list_p, edge_p);
+            if (E_SUCCESS != exit_code)
+            {
+                print_error(
+                    "graph_add_edge(): Unable to rollback previous add.");
+            }
+            node_1_p->edge_count -= 1;
+            exit_code = E_FAILURE;
             goto END;
         }
-        node_2->edge_count += 1;
+        node_2_p->edge_count += 1;
     }
 
     exit_code = E_SUCCESS;
 END:
+    if (E_SUCCESS != exit_code)
+    {
+        free(edge_p);
+        edge_p = NULL;
+    }
     return exit_code;
 }
 
-int graph_remove_edge(graph_t * graph, void * data_1, void * data_2)
+int graph_remove_edge(graph_t * graph_p, void * data_1_p, void * data_2_p)
 {
     int      exit_code = E_FAILURE;
-    node_t * node_1    = NULL;
-    node_t * node_2    = NULL;
-    edge_t * edge      = NULL;
+    node_t * node_1_p  = NULL;
+    node_t * node_2_p  = NULL;
+    edge_t * edge_p    = NULL;
 
-    if ((NULL == graph) || (NULL == data_1) || (NULL == data_2))
+    if ((NULL == graph_p) || (NULL == data_1_p) || (NULL == data_2_p))
     {
         print_error("graph_remove_edge(): NULL argument passed.");
         goto END;
     }
 
-    node_1 = graph_find_node(graph, data_1);
-    if (NULL == node_1)
+    node_1_p = graph_find_node(graph_p, data_1_p);
+    if (NULL == node_1_p)
     {
         print_error("graph_remove_edge(): Unable to find node 1.");
         goto END;
     }
 
-    node_2 = graph_find_node(graph, data_2);
-    if (NULL == node_2)
+    node_2_p = graph_find_node(graph_p, data_2_p);
+    if (NULL == node_2_p)
     {
         print_error("graph_remove_edge(): Unable to find node 2.");
         goto END;
     }
 
-    edge = graph_find_edge(graph, node_1, node_2);
-    if (NULL == edge)
+    edge_p = graph_find_edge(graph_p, node_1_p, node_2_p);
+    if (NULL == edge_p)
     {
         print_error("graph_remove_edge(): Unable to find edge.");
         goto END;
     }
 
-    // Remove the edge from node 1's edge list
-    exit_code = list_remove_data(node_1->edge_list, edge);
+    // Remove the edge
+    exit_code = list_remove_data(node_1_p->edge_list_p, edge_p);
     if (E_SUCCESS != exit_code)
     {
         print_error(
@@ -336,708 +324,242 @@ int graph_remove_edge(graph_t * graph, void * data_1, void * data_2)
             "list.");
         goto END;
     }
-    node_1->edge_count -= 1;
+    node_1_p->edge_count -= 1;
 
-    // Remove the edge from node 2's edge list if the edge is bidirectional
-    if (!edge->is_directed)
+    // Remove the edge from node 2's list if non-directed
+    if (false == edge_p->is_directed)
     {
-        exit_code = list_remove_data(node_2->edge_list, edge);
+        exit_code = list_remove_data(node_2_p->edge_list_p, edge_p);
         if (E_SUCCESS != exit_code)
         {
             print_error(
                 "graph_remove_edge(): Unable to remove edge from node 2's edge "
                 "list.");
-            // Rollback previous removal from node 1's list
-            list_push_head(node_1->edge_list, edge);
-            node_1->edge_count += 1;
             goto END;
         }
-        node_2->edge_count -= 1;
+        node_2_p->edge_count -= 1;
     }
 
-    // Free the edge memory
-    free(edge);
-    edge = NULL;
+    free(edge_p);
+    edge_p = NULL;
 
     exit_code = E_SUCCESS;
 END:
     return exit_code;
 }
-
-size_t graph_get_size(graph_t * graph)
+size_t graph_get_size(graph_t * graph_p)
 {
     size_t size = 0;
 
-    if (NULL == graph)
+    if (NULL == graph_p)
     {
         print_error("graph_get_size(): NULL argument passed.");
         goto END;
     }
 
-    size = graph->node_count;
+    size = graph_p->node_count;
 
 END:
     return size;
 }
 
-void graph_print(graph_t * graph, ACTION_F custom_print)
-{
-    list_node_t * current    = NULL;
-    node_t *      graph_node = NULL;
-
-    if ((NULL == graph) || (NULL == custom_print))
-    {
-        print_error("graph_print(): NULL argument passed.");
-        goto END;
-    }
-
-    current = graph->node_list->head;
-    while (NULL != current)
-    {
-        graph_node = (node_t *)(current->data);
-        printf("Node: ");
-        custom_print(graph_node->data);
-        printf(" with %zu edges.\n", graph_node->edge_count);
-
-        current = current->next;
-    }
-
-END:
-    return;
-}
-
-int graph_clear(graph_t * graph)
-{
-    int           exit_code = E_FAILURE;
-    list_node_t * current   = NULL;
-    list_node_t * next      = NULL;
-    node_t *      node      = NULL;
-
-    if (NULL == graph)
-    {
-        print_error("graph_clear(): NULL argument passed.");
-        goto END;
-    }
-
-    current = graph->node_list->head;
-    while (NULL != current)
-    {
-        node = (node_t *)current->data;
-        next = current->next;
-
-        cleanup_node(graph, node);
-
-        current = next;
-    }
-
-    exit_code = list_delete(&(graph->node_list));
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_clear(): Unable to reset graph's node list.");
-        goto END;
-    }
-
-    graph->node_list  = NULL;
-    graph->node_count = 0;
-
-    exit_code = E_SUCCESS;
-END:
-    return exit_code;
-}
-
-int graph_destroy(graph_t ** graph)
-{
-    int exit_code = E_FAILURE;
-
-    if ((graph == NULL) || (*graph == NULL))
-    {
-        print_error("graph_destroy(): NULL graph pointer.");
-        goto END;
-    }
-
-    exit_code = graph_clear(*graph);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_destroy(): Unable to clear graph.");
-        goto END;
-    }
-
-    // Finally, free the graph structure
-    free(*graph);
-    *graph = NULL; // Avoid dangling pointer
-
-END:
-    return exit_code;
-}
-
-static int initialize_dfs(graph_t *  graph,
-                          void *     start_data,
-                          list_t **  visited_list,
-                          stack_t ** stack,
-                          node_t **  start_node)
+node_t * graph_find_node(graph_t * graph_p, void * data_p)
 {
-    int exit_code = E_FAILURE;
+    list_node_t * list_node_p = NULL;
+    node_t *      node_p      = NULL;
 
-    if ((NULL == graph) || (NULL == start_data) || (NULL == visited_list) ||
-        (NULL == stack) || (NULL == start_node))
+    if ((NULL == graph_p) || (NULL == data_p))
     {
-        print_error("initialize_dfs(): NULL argument passed.");
-        goto END;
-    }
-
-    *start_node = graph_find_node(graph, start_data);
-    if (NULL == *start_node)
-    {
-        print_error("initialize_dfs(): Unable to find start node.");
+        print_error("graph_find_node(): NULL argument passed.");
         goto END;
     }
 
-    *visited_list = list_new(noop_free, node_ptr_comp);
-    if (NULL == *visited_list)
+    list_node_p = list_find_first_occurrence(graph_p->node_list_p, &data_p);
+    if (NULL == list_node_p)
     {
-        print_error("initialize_dfs(): Failed to create visited list.");
-        goto END;
+        print_error("graph_find_node(): Unable to find first occurrence.");
     }
 
-    *stack = stack_init(MAX_STACK_SIZE, free);
-    if (NULL == *stack)
-    {
-        print_error("initialize_dfs(): Failed to create stack.");
-        list_delete(visited_list);
-        goto END;
-    }
+    node_p = (node_t *)list_node_p->data;
 
-    exit_code = E_SUCCESS;
 END:
-    return exit_code;
+    return node_p;
 }
-
-static int dfs_visit_node(stack_t * stack, list_t * visited_list, node_t * node)
+edge_t * graph_find_edge(graph_t * graph_p,
+                         node_t *  node_1_p,
+                         node_t *  node_2_p)
 {
-    int exit_code = E_FAILURE;
+    edge_t *      edge_p      = NULL;
+    list_t *      edge_list_p = NULL;
+    list_node_t * current_p   = NULL;
 
-    if ((NULL == stack) || (NULL == visited_list) || (NULL == node))
+    if ((NULL == graph_p) || (NULL == node_1_p) || (NULL == node_2_p))
     {
-        print_error("dfs_visit_node(): NULL argument passed.");
-        goto END;
-    }
-
-    exit_code = stack_push(stack, node);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("dfs_visit_node(): Unable to push node onto stack.");
+        print_error("graph_find_edge(): NULL argument passed.");
         goto END;
     }
 
-    exit_code = list_push_tail(visited_list, node);
-    if (E_SUCCESS != exit_code)
+    edge_list_p = node_1_p->edge_list_p;
+    if (NULL == edge_list_p)
     {
-        print_error("dfs_visit_node(): Unable to push node onto visited list.");
+        print_error("graph_find_edge(): Node 1 does not have an edge list.");
         goto END;
     }
 
-    exit_code = E_SUCCESS;
-END:
-    return exit_code;
-}
-
-static int traverse_dfs(stack_t * stack, list_t * visited_list, ACTION_F action)
-{
-    int           exit_code = E_FAILURE;
-    node_t *      current   = NULL;
-    list_node_t * edge_node = NULL;
-    edge_t *      edge      = NULL;
-    node_t *      neighbor  = NULL;
-
-    if ((NULL == stack) || (NULL == visited_list) || (NULL == action))
+    // Find the edge that connects to node 2
+    current_p = edge_list_p->head;
+    while (NULL != current_p)
     {
-        print_error("traverse_dfs(): NULL argument passed.");
-        goto END;
-    }
+        edge_p = (edge_t *)current_p->data;
 
-    while (E_FAILURE == stack_is_empty(stack))
-    {
-        current = (node_t *)stack_pop(stack);
-        if (NULL == current)
+        // Check if the current edge connects to node 2
+        if (((edge_p->node_1_p == node_1_p) &&
+             (edge_p->node_2_p == node_2_p)) ||
+            ((edge_p->node_1_p == node_2_p) && (edge_p->node_2_p == node_1_p) &&
+             false == edge_p->is_directed))
         {
-            print_error("traverse_dfs(): NULL data popped from stack.");
+            // Found the edge
             goto END;
         }
 
-        action(current->data);
-
-        edge_node = current->edge_list->head;
-        while (NULL != edge_node)
-        {
-            edge     = (edge_t *)edge_node->data;
-            neighbor = edge->node_2;
-
-            if (false == list_contains(visited_list, neighbor))
-            {
-                if (E_SUCCESS != dfs_visit_node(stack, visited_list, neighbor))
-                {
-                    print_error("traverse_dfs(): Unable to visit neighbor.");
-                    goto END;
-                }
-            }
-
-            edge_node = edge_node->next;
-        }
-    }
-
-    exit_code = E_SUCCESS;
-END:
-    return exit_code;
-}
-
-int graph_dfs(graph_t * graph, void * start_data, ACTION_F action)
-{
-    int       exit_code    = E_FAILURE;
-    list_t *  visited_list = NULL;
-    stack_t * stack        = NULL;
-    node_t *  start_node   = NULL;
-
-    if ((NULL == graph) || (NULL == start_data) || (NULL == action))
-    {
-        print_error("graph_dfs(): NULL argument passed.");
-        goto END;
-    }
-
-    exit_code =
-        initialize_dfs(graph, start_data, &visited_list, &stack, &start_node);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_dfs(): Unable to initialize DFS.");
-        goto END;
-    }
-
-    exit_code = dfs_visit_node(stack, visited_list, start_node);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_dfs(): Unable to visit node.");
-        goto END;
-    }
-
-    exit_code = traverse_dfs(stack, visited_list, action);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_dfs(): Unable to perform DFS traversal.");
-        goto END;
-    }
-
-END:
-    stack_destroy(&stack);
-    list_delete(&visited_list);
-    return exit_code;
-}
-
-static int bfs_visit_node(queue_t * queue, list_t * visited_list, node_t * node)
-{
-    int exit_code = E_FAILURE;
-
-    if ((NULL == queue) || (NULL == visited_list) || (NULL == node))
-    {
-        print_error("bfs_visit_node(): NULL argument passed.");
-        goto END;
-    }
-
-    exit_code = queue_enqueue(queue, node);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("bfs_visit_node(): Unable to enqueue node.");
-        goto END;
-    }
-
-    exit_code = list_push_tail(visited_list, node);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("bfs_visit_node(): Unable to push node onto visited list.");
-        goto END;
+        current_p = current_p->next;
     }
 
-    exit_code = E_SUCCESS;
 END:
-    return exit_code;
+    return edge_p;
 }
 
-static int initialize_bfs(graph_t *  graph,
-                          void *     start_data,
-                          list_t **  visited_list,
-                          queue_t ** queue,
-                          node_t **  start_node)
+void graph_print(graph_t * graph_p, PRINT_F custom_print)
 {
-    int exit_code = E_FAILURE;
+    list_node_t * current_p    = NULL;
+    node_t *      graph_node_p = NULL;
 
-    if ((NULL == graph) || (NULL == start_data) || (NULL == visited_list) ||
-        (NULL == queue) || (NULL == start_node))
+    if ((NULL == graph_p) || (NULL == custom_print))
     {
-        print_error("initialize_bfs(): NULL argument passed.");
-        goto END;
-    }
-
-    *visited_list = list_new(noop_free, node_ptr_comp);
-    if (NULL == *visited_list)
-    {
-        print_error("initialize_dfs(): Failed to create visited list.");
+        print_error("graph_print(): NULL argument passed.");
         goto END;
     }
 
-    *start_node = graph_find_node(graph, start_data);
-    if (NULL == *start_node)
+    current_p = graph_p->node_list_p->head;
+    while (NULL != current_p)
     {
-        print_error("initialize_bfs(): Unable to find start node.");
-        goto END;
-    }
+        graph_node_p = (node_t *)(current_p->data);
+        printf("Node: ");
+        custom_print(graph_node_p->data_p);
+        printf(" with %zu edges.\n", graph_node_p->edge_count);
 
-    *queue = queue_init(free);
-    if (NULL == *queue)
-    {
-        print_error("initialize_bfs(): Failed to create queue.");
-        goto END;
+        current_p = current_p->next;
     }
 
-    exit_code = E_SUCCESS;
 END:
-    return exit_code;
+    return;
 }
 
-static int traverse_bfs(queue_t * queue, list_t * visited_list, ACTION_F action)
+int graph_clear(graph_t * graph_p)
 {
     int           exit_code = E_FAILURE;
-    node_t *      current   = NULL;
-    list_node_t * edge_node = NULL;
-    edge_t *      edge      = NULL;
-    node_t *      neighbor  = NULL;
+    list_node_t * current_p = NULL;
+    list_node_t * next_p    = NULL;
+    node_t *      node_p    = NULL;
 
-    if ((NULL == queue) || (NULL == visited_list) || (NULL == action))
+    if (NULL == graph_p)
     {
-        print_error("traverse_bfs(): NULL argument passed.");
+        print_error("graph_clear(): NULL argument passed.");
         goto END;
     }
 
-    while (false == queue_is_empty(queue))
+    current_p = graph_p->node_list_p->head;
+    while (NULL != current_p)
     {
-        current = (node_t *)queue_dequeue(queue);
-        if (NULL == current)
-        {
-            print_error("traverse_bfs(): NULL data dequeued.");
-            goto END;
-        }
+        node_p = (node_t *)current_p->data;
+        next_p = current_p->next;
 
-        action(current->data);
+        cleanup_node(graph_p, node_p);
 
-        edge_node = current->edge_list->head;
-        while (NULL != edge_node)
-        {
-            edge     = (edge_t *)edge_node->data;
-            neighbor = edge->node_2;
-
-            if (false == list_contains(visited_list, neighbor))
-            {
-                if (E_SUCCESS != bfs_visit_node(queue, visited_list, neighbor))
-                {
-                    print_error("traverse_bfs(): Unable to visit neighbor.");
-                    goto END;
-                }
-            }
-
-            edge_node = edge_node->next;
-        }
-    }
-
-    exit_code = E_SUCCESS;
-END:
-    return exit_code;
-}
-
-int graph_bfs(graph_t * graph, void * start_data, ACTION_F action)
-{
-    int       exit_code    = E_FAILURE;
-    list_t *  visited_list = NULL;
-    queue_t * queue        = NULL;
-    node_t *  start_node   = NULL;
-
-    if ((NULL == graph) || (NULL == start_data) || (NULL == action))
-    {
-        print_error("graph_bfs(): NULL argument passed.");
-        goto END;
-    }
-
-    exit_code =
-        initialize_bfs(graph, start_data, &visited_list, &queue, &start_node);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_bfs(): Unable to initialize BFS.");
-        goto END;
+        current_p = next_p;
     }
 
-    exit_code = bfs_visit_node(queue, visited_list, start_node);
+    exit_code = list_delete(&(graph_p->node_list_p));
     if (E_SUCCESS != exit_code)
     {
-        print_error("graph_bfs(): Unable to visit node.");
+        print_error("graph_clear(): Unable to reset graph's node list.");
         goto END;
     }
 
-    exit_code = traverse_bfs(queue, visited_list, action);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("graph_bfs(): Unable to perform BFS traversal.");
-        goto END;
-    }
+    graph_p->node_list_p = NULL;
+    graph_p->node_count  = 0;
 
     exit_code = E_SUCCESS;
 END:
-    queue_destroy(&queue);
-    list_delete(&visited_list);
-    return exit_code;
-}
-
-int graph_dijkstra(graph_t * graph,
-                   void *    start_data,
-                   void *    end_data,
-                   list_t ** path)
-{
-    (void)graph;
-    (void)start_data;
-    (void)end_data;
-    (void)path;
-    return -1;
-}
-
-int graph_a_star(graph_t * graph,
-                 void *    start_data,
-                 void *    end_data,
-                 list_t ** path)
-{
-    (void)graph;
-    (void)start_data;
-    (void)end_data;
-    (void)path;
-    return -1;
-}
-
-int graph_floyd_warshall(graph_t * graph, size_t *** distances)
-{
-    (void)graph;
-    (void)distances;
-    return -1;
-}
-
-int graph_is_connected(graph_t * graph, bool * is_connected)
-{
-    int exit_code = E_FAILURE;
-
-    (void)graph;
-    (void)is_connected;
-
-    return exit_code;
-}
-
-int graph_is_cyclic(graph_t * graph, bool * is_cyclic)
-{
-    int exit_code = E_FAILURE;
-
-    (void)graph;
-    (void)is_cyclic;
-
     return exit_code;
 }
 
-list_t * graph_find_connected_components(graph_t * graph)
-{
-    list_t * connected_components = NULL;
-
-    (void)graph;
-
-    return connected_components;
-}
-
-int graph_node_degree(graph_t * graph, void * data, size_t * degree)
+int graph_destroy(graph_t ** graph_pp)
 {
     int exit_code = E_FAILURE;
 
-    (void)graph;
-    (void)data;
-    (void)degree;
-
-    return exit_code;
-}
-
-list_t * graph_get_adjacent_nodes(graph_t * graph, void * data)
-{
-    (void)graph;
-    (void)data;
-    return NULL;
-}
-
-bool graph_edge_exists(graph_t * graph, void * data_1, void * data_2)
-{
-    (void)graph;
-    (void)data_1;
-    (void)data_2;
-    return false;
-}
-
-size_t graph_get_edge_weight(graph_t * graph, void * data_1, void * data_2)
-{
-    (void)graph;
-    (void)data_1;
-    (void)data_2;
-    return -1;
-}
-
-graph_t * graph_clone(graph_t * graph)
-{
-    (void)graph;
-    return NULL;
-}
-
-// STATIC FUNCTIONS
-
-static node_t * graph_create_node(void * data)
-{
-    node_t * new_node = NULL;
-
-    if (NULL == data)
-    {
-        print_error("graph_create_node(): NULL data passed.");
-        goto END;
-    }
-
-    new_node = calloc(1, sizeof(node_t));
-    if (NULL == new_node)
-    {
-        print_error("graph_create_node(): CMR failure.");
-        goto END;
-    }
-
-    new_node->data       = data;
-    new_node->edge_count = 0;
-    new_node->edge_list  = list_new(edge_list_free, edge_compare);
-    if (NULL == new_node->edge_list)
-    {
-        print_error("graph_create_node(): CMR failure.");
-        free(new_node);
-        new_node = NULL;
-        goto END;
-    }
-
-END:
-    return new_node;
-}
-
-static node_t * graph_find_node(graph_t * graph, void * data)
-{
-    list_node_t * list_node = NULL;
-    node_t *      node      = NULL;
-
-    if ((NULL == graph) || (NULL == data))
+    if ((graph_pp == NULL) || (*graph_pp == NULL))
     {
-        print_error("graph_find_node(): NULL argument passed.");
+        print_error("graph_destroy(): NULL graph pointer.");
         goto END;
     }
 
-    list_node = list_find_first_occurrence(graph->node_list, &data);
-    if (NULL == list_node)
+    exit_code = graph_clear(*graph_pp);
+    if (E_SUCCESS != exit_code)
     {
-        print_error("graph_find_node(): Unable to find first occurrence.");
+        print_error("graph_destroy(): Unable to clear graph.");
         goto END;
     }
 
-    node = ((node_t *)list_node->data);
+    // Finally, free the graph structure
+    free(*graph_pp);
+    *graph_pp = NULL; // Avoid dangling pointer
 
 END:
-    return node;
+    return exit_code;
 }
 
-static edge_t * graph_find_edge(graph_t * graph,
-                                node_t *  node_1,
-                                node_t *  node_2)
-{
-    edge_t *      edge      = NULL;
-    list_t *      edge_list = NULL;
-    list_node_t * current   = NULL;
-
-    if ((NULL == graph) || (NULL == node_1) || (NULL == node_2))
-    {
-        print_error("graph_find_edge(): NULL argument passed.");
-        goto END;
-    }
-
-    edge_list = node_1->edge_list;
-    if (NULL == edge_list)
-    {
-        print_error("graph_find_edge(): Node 1 does not have an edge list.");
-        goto END;
-    }
-
-    // Find the edge that connects to node 2
-    current = edge_list->head;
-    while (NULL != current)
-    {
-        edge = (edge_t *)current->data;
-
-        // Check if the current edge connects to node 2
-        if (((edge->node_1 == node_1) && (edge->node_2 == node_2)) ||
-            ((edge->node_1 == node_2) && (edge->node_2 == node_1) &&
-             false == edge->is_directed))
-        {
-            // Found the edge
-            goto END;
-        }
-
-        current = current->next;
-    }
-
-END:
-    return edge;
-}
+// STATIC FUNCTIONS
 
-static edge_t ** collect_edges(node_t * node, uint32_t * num_edges)
+static edge_t ** collect_edges(node_t * node_p, size_t * num_edges)
 {
-    edge_t **     edge_list = NULL;
-    list_node_t * current   = NULL;
-    size_t        index     = 0;
+    edge_t **     edge_list_pp = NULL;
+    list_node_t * current_p    = NULL;
+    size_t        index        = 0;
 
-    if ((NULL == node) || (NULL == num_edges))
+    if ((NULL == node_p) || (NULL == num_edges))
     {
         print_error("collect_edges(): NULL argument passed.");
         goto END;
     }
 
-    if (NULL == node->edge_list)
-    {
-        print_error("collect_edges(): NULL edge list.");
-        goto END;
-    }
-
-    *num_edges = node->edge_list->size;
+    *num_edges = node_p->edge_list_p->size;
 
-    edge_list = calloc(*num_edges, sizeof(edge_t *));
-    if (NULL == edge_list)
+    edge_list_pp = calloc(*num_edges, sizeof(edge_t *));
+    if (NULL == edge_list_pp)
     {
         print_error("collect_edges(): CMR failure.");
         goto END;
     }
 
-    current = node->edge_list->head;
-    while ((NULL != current) && (index < *num_edges))
+    current_p = node_p->edge_list_p->head;
+    while ((NULL != current_p) && (index < *num_edges))
     {
-        edge_list[index++] = (edge_t *)current->data;
-        current            = current->next;
+        edge_list_pp[index++] = (edge_t *)current_p->data;
+        current_p             = current_p->next;
     }
 
 END:
-    return edge_list;
+    return edge_list_pp;
 }
 
-static int remove_edges(graph_t * graph,
-                        edge_t ** edges_to_remove,
+static int remove_edges(graph_t * graph_p,
+                        edge_t ** edges_to_remove_pp,
                         size_t    num_edges)
 {
     int exit_code = E_FAILURE;
 
-    if ((NULL == graph) || (NULL == edges_to_remove))
+    if ((NULL == graph_p) || (NULL == edges_to_remove_pp))
     {
         print_error("remove_edges(): NULL argument passed.");
         goto END;
@@ -1045,9 +567,10 @@ static int remove_edges(graph_t * graph,
 
     for (size_t idx = 0; idx < num_edges; ++idx)
     {
-        exit_code = graph_remove_edge(graph,
-                                      edges_to_remove[idx]->node_1->data,
-                                      edges_to_remove[idx]->node_2->data);
+        exit_code =
+            graph_remove_edge(graph_p,
+                              edges_to_remove_pp[idx]->node_1_p->data_p,
+                              edges_to_remove_pp[idx]->node_2_p->data_p);
         if (E_SUCCESS != exit_code)
         {
             print_error("remove_edges(): Unable to remove edge.");
@@ -1060,25 +583,26 @@ END:
     return exit_code;
 }
 
-static void cleanup_node(graph_t * graph, node_t * node)
+static void cleanup_node(graph_t * graph_p, node_t * node_p)
 {
     int exit_code = E_FAILURE;
 
-    if ((NULL == graph) || (NULL == node))
+    if ((NULL == graph_p) || (NULL == node_p))
     {
         print_error("cleanup_node(): NULL argument passed.");
         goto END;
     }
 
     // Free the nodes data and the node itself, and remove the edge list
-    graph->custom_free(node->data);
-    node->data = NULL;
+    graph_p->custom_free(node_p->data_p);
+    node_p->data_p     = NULL;
+    node_p->edge_count = 0;
 
-    node->edge_count = 0;
+    free(node_p->edge_list_p);
+    node_p->edge_list_p = NULL;
 
-    list_delete(&(node->edge_list));
-    free(node);
-    node = NULL;
+    free(node_p);
+    node_p = NULL;
 
     (void)exit_code;
 END:
diff --git a/libraries/DSA/adjacency_list/tests/adjacency_list_tests.c b/libraries/DSA/adjacency_list/tests/adjacency_list_tests.c
deleted file mode 100644
index ca4183d..0000000
--- a/libraries/DSA/adjacency_list/tests/adjacency_list_tests.c
+++ /dev/null
@@ -1,304 +0,0 @@
-#include <CUnit/Basic.h>
-#include <CUnit/CUnit.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdlib.h>
-
-#include "adjacency_list.h"
-#include "comparisons.h"
-#include "utilities.h"
-
-graph_t * test_graph = NULL;
-
-void custom_free(void * data)
-{
-    (void)data;
-    return;
-}
-
-void custom_print(const void * data)
-{
-    int * int_data = (int *)data;
-    printf("%d ", *int_data);
-}
-
-void setup(void)
-{
-    test_graph = graph_create(custom_free, int_comp);
-}
-
-void teardown(void)
-{
-    if (NULL != test_graph)
-    {
-        graph_destroy(&test_graph);
-    }
-}
-
-void test_graph_create(void)
-{
-    CU_ASSERT_PTR_NOT_NULL_FATAL(test_graph);
-    CU_ASSERT_EQUAL(test_graph->node_count, 0);
-    CU_ASSERT_PTR_NOT_NULL_FATAL(test_graph->node_list);
-}
-
-void test_graph_add_node(void)
-{
-    int exit_code = E_FAILURE;
-    int data      = 1;
-
-    exit_code = graph_add_node(test_graph, &data);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(test_graph->node_count, 1);
-}
-
-void test_graph_remove_node(void)
-{
-    int exit_code = E_FAILURE;
-    int data      = 1;
-
-    exit_code = graph_add_node(test_graph, &data);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(test_graph->node_count, 1);
-
-    exit_code = graph_remove_node(test_graph, &data);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(test_graph->node_count, 0);
-}
-
-void test_graph_add_edge(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-}
-
-void test_graph_remove_edge(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_remove_edge(test_graph, &data1, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-}
-
-void test_graph_is_connected(void)
-{
-    int  exit_code = E_FAILURE;
-    int  data1 = 1, data2 = 2;
-    bool is_connected = false;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_is_connected(test_graph, &is_connected);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_FALSE(is_connected);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_is_connected(test_graph, &is_connected);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_TRUE(is_connected);
-}
-
-void test_graph_is_cyclic(void)
-{
-    int  exit_code = E_FAILURE;
-    int  data1 = 1, data2 = 2;
-    bool is_cyclic = false;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_is_cyclic(test_graph, &is_cyclic);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_FALSE(is_cyclic);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_edge(test_graph, &data2, &data1, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_is_cyclic(test_graph, &is_cyclic);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_TRUE(is_cyclic);
-}
-
-void test_graph_node_degree(void)
-{
-    int    exit_code = E_FAILURE;
-    int    data1 = 1, data2 = 2;
-    size_t degree = 0;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_node_degree(test_graph, &data1, &degree);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(degree, 0);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_node_degree(test_graph, &data1, &degree);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(degree, 1);
-}
-
-void test_graph_get_adjacent_nodes(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    list_t * adjacent_nodes = graph_get_adjacent_nodes(test_graph, &data1);
-    CU_ASSERT_PTR_NOT_NULL_FATAL(adjacent_nodes);
-    CU_ASSERT_EQUAL(adjacent_nodes->size, 1);
-    list_delete(&adjacent_nodes);
-}
-
-void test_graph_edge_exists(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    CU_ASSERT_TRUE(graph_edge_exists(test_graph, &data1, &data2));
-    CU_ASSERT_FALSE(graph_edge_exists(test_graph, &data2, &data1));
-}
-
-void test_graph_get_edge_weight(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    CU_ASSERT_EQUAL(graph_get_edge_weight(test_graph, &data1, &data2), 10);
-}
-
-void test_graph_clone(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    graph_t * clone = graph_clone(test_graph);
-    CU_ASSERT_PTR_NOT_NULL_FATAL(clone);
-    CU_ASSERT_EQUAL(clone->node_count, 2);
-    CU_ASSERT_TRUE(graph_edge_exists(clone, &data1, &data2));
-    graph_destroy(&clone);
-}
-
-void test_graph_dfs(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_dfs(test_graph, &data1, custom_print);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-}
-
-void test_graph_bfs(void)
-{
-    int exit_code = E_FAILURE;
-    int data1 = 1, data2 = 2;
-
-    exit_code = graph_add_node(test_graph, &data1);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = graph_add_node(test_graph, &data2);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_add_edge(test_graph, &data1, &data2, 10, false);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = graph_bfs(test_graph, &data1, custom_print);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-}
-
-static CU_TestInfo adjacency_list_tests[] = {
-    { "graph_create", test_graph_create },
-    { "graph_add_node", test_graph_add_node },
-    { "graph_remove_node", test_graph_remove_node },
-    { "graph_add_edge", test_graph_add_edge },
-    { "graph_remove_edge", test_graph_remove_edge },
-    { "graph_is_connected", test_graph_is_connected },
-    { "graph_is_cyclic", test_graph_is_cyclic },
-    { "graph_node_degree", test_graph_node_degree },
-    { "graph_get_adjacent_nodes", test_graph_get_adjacent_nodes },
-    { "graph_edge_exists", test_graph_edge_exists },
-    { "graph_get_edge_weight", test_graph_get_edge_weight },
-    { "graph_clone", test_graph_clone },
-    { "graph_dfs", test_graph_dfs },
-    { "graph_bfs", test_graph_bfs },
-    CU_TEST_INFO_NULL
-};
-
-CU_SuiteInfo adjacency_list_test_suite = {
-    "Adjacency List Tests",
-    NULL,                // Suite initialization function
-    NULL,                // Suite cleanup function
-    setup,               // Suite setup function
-    teardown,            // Suite teardown function
-    adjacency_list_tests // The combined array of all tests
-};
-
-/*** end of file ***/
diff --git a/libraries/DSA/adjacency_list/tests/test_runner.c b/libraries/DSA/adjacency_list/tests/test_runner.c
deleted file mode 100644
index 1db1670..0000000
--- a/libraries/DSA/adjacency_list/tests/test_runner.c
+++ /dev/null
@@ -1,21 +0,0 @@
-#include <CUnit/Basic.h>
-#include <CUnit/CUnit.h>
-
-int main(void)
-{
-    CU_basic_set_mode(CU_BRM_VERBOSE);
-
-    extern CU_SuiteInfo adjacency_list_test_suite;
-
-    CU_SuiteInfo suites[] = { adjacency_list_test_suite, CU_SUITE_INFO_NULL };
-
-    CU_initialize_registry();
-
-    CU_register_suites(suites);
-
-    CU_basic_run_tests();
-
-    CU_cleanup_registry();
-}
-
-/*** end of file ***/
diff --git a/libraries/DSA/adjacency_matrix/include/adjacency_matrix.h b/libraries/DSA/adjacency_matrix/include/adjacency_matrix.h
index 20577a8..67326a5 100644
--- a/libraries/DSA/adjacency_matrix/include/adjacency_matrix.h
+++ b/libraries/DSA/adjacency_matrix/include/adjacency_matrix.h
@@ -11,15 +11,16 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#include "callback_types.h"
+#include "comparisons.h"
 
 typedef void (*FREE_F)(void *);
+typedef void (*ACTION_F)(const void *, const char *);
 typedef bool (*PREDICATE_F)(const void *, const char *);
 typedef size_t (*HEURISTIC_F)(const char *, const char *);
 
 typedef struct matrix matrix_t;
-typedef struct node   node_t;
-typedef struct edge   edge_t;
+typedef struct node node_t;
+typedef struct edge edge_t;
 
 // Primary API functions
 
@@ -33,17 +34,17 @@ typedef struct edge   edge_t;
  * @return A pointer to the newly created graph, or NULL if initialization
  * fails.
  */
-matrix_t * matrix_init(size_t num_nodes,
-                       bool   is_directed,
-                       CMP_F  custom_compare,
-                       FREE_F custom_free);
+matrix_t *matrix_init(size_t num_nodes,
+                      bool is_directed,
+                      CMP_F custom_compare,
+                      FREE_F custom_free);
 
 /**
  * @brief Destroys the graph and frees all associated memory.
  *
  * @param graph_address Pointer to the graph to be destroyed.
  */
-void matrix_destroy(matrix_t ** graph_address);
+void matrix_destroy(matrix_t **graph_address);
 
 /**
  * @brief Populates a pre-allocated node in the graph with data and a label.
@@ -54,10 +55,10 @@ void matrix_destroy(matrix_t ** graph_address);
  * @param label The label to assign to the node.
  * @return Status code indicating success or failure.
  */
-int matrix_populate_node(matrix_t * graph,
-                         size_t     index,
-                         void *     data,
-                         char *     label);
+int matrix_populate_node(matrix_t *graph,
+                         size_t index,
+                         void *data,
+                         char *label);
 
 /**
  * @brief Depopulates a node in the graph by freeing the data and the label.
@@ -66,7 +67,7 @@ int matrix_populate_node(matrix_t * graph,
  * @param index The index of the node to depopulate.
  * @return Status code indicating success or failure.
  */
-int matrix_depopulate_node(matrix_t * graph, size_t index);
+int matrix_depopulate_node(matrix_t *graph, size_t index);
 
 /**
  * @brief Adds a new node to the graph.
@@ -76,7 +77,7 @@ int matrix_depopulate_node(matrix_t * graph, size_t index);
  * @param label The label of the node.
  * @return Status code indicating success or failure.
  */
-int matrix_add_node(matrix_t * graph, const void * data, char * label);
+int matrix_add_node(matrix_t *graph, const void *data, char *label);
 
 /**
  * @brief Removes a node and its associated edges from the graph.
@@ -85,7 +86,7 @@ int matrix_add_node(matrix_t * graph, const void * data, char * label);
  * @param label The label of the node to remove.
  * @return Status code indicating success or failure.
  */
-int matrix_remove_node(matrix_t * graph, char * label);
+int matrix_remove_node(matrix_t *graph, char *label);
 
 /**
  * @brief Retrieves the data associated with a specific node.
@@ -95,9 +96,9 @@ int matrix_remove_node(matrix_t * graph, char * label);
  * @param data Out parameter for the node's data.
  * @return Status code indicating success or failure.
  */
-int matrix_get_node_data(const matrix_t * graph,
-                         const char *     label,
-                         void **          data);
+int matrix_get_node_data(const matrix_t *graph,
+                         const char *label,
+                         void **data);
 
 /**
  * @brief Adds an edge between two nodes specified by their labels.
@@ -108,10 +109,10 @@ int matrix_get_node_data(const matrix_t * graph,
  * @param weight The weight of the edge.
  * @return Status code indicating success or failure.
  */
-int matrix_add_edge_by_label(matrix_t *   graph,
-                             const char * src_label,
-                             const char * dst_label,
-                             size_t       weight);
+int matrix_add_edge_by_label(matrix_t *graph,
+                             const char *src_label,
+                             const char *dst_label,
+                             size_t weight);
 
 /**
  * @brief Removes an edge between two nodes specified by their labels.
@@ -121,9 +122,9 @@ int matrix_add_edge_by_label(matrix_t *   graph,
  * @param dst_label The label of the destination node.
  * @return Status code indicating success or failure.
  */
-int matrix_remove_edge_by_label(matrix_t *   graph,
-                                const char * src_label,
-                                const char * dst_label);
+int matrix_remove_edge_by_label(matrix_t *graph,
+                                const char *src_label,
+                                const char *dst_label);
 
 /**
  * @brief Sets the weight of an existing edge between two nodes.
@@ -134,10 +135,10 @@ int matrix_remove_edge_by_label(matrix_t *   graph,
  * @param edge_weight The new weight of the edge.
  * @return Status code indicating success or failure.
  */
-int matrix_set_edge_weight_by_label(matrix_t *   graph,
-                                    const char * src_label,
-                                    const char * dst_label,
-                                    size_t       edge_weight);
+int matrix_set_edge_weight_by_label(matrix_t *graph,
+                                    const char *src_label,
+                                    const char *dst_label,
+                                    size_t edge_weight);
 
 /**
  * @brief Gets the weight of an edge between two nodes.
@@ -148,10 +149,10 @@ int matrix_set_edge_weight_by_label(matrix_t *   graph,
  * @param edge_weight Out parameter for the weight of the edge.
  * @return Status code indicating success or failure.
  */
-int matrix_get_edge_weight_by_label(const matrix_t * graph,
-                                    const char *     src_label,
-                                    const char *     dst_label,
-                                    size_t *         edge_weight);
+int matrix_get_edge_weight_by_label(const matrix_t *graph,
+                                    const char *src_label,
+                                    const char *dst_label,
+                                    size_t *edge_weight);
 
 /**
  * @brief Checks if there is an edge between two nodes.
@@ -161,9 +162,9 @@ int matrix_get_edge_weight_by_label(const matrix_t * graph,
  * @param dst_label The label of the destination node.
  * @return 'true' if an edge exists, 'false' otherwise.
  */
-int matrix_has_edge_by_label(const matrix_t * graph,
-                             const char *     src_label,
-                             const char *     dst_label);
+int matrix_has_edge_by_label(const matrix_t *graph,
+                             const char *src_label,
+                             const char *dst_label);
 
 /**
  * @brief Retrieves the indices of all neighbors of a node.
@@ -174,10 +175,10 @@ int matrix_has_edge_by_label(const matrix_t * graph,
  * @param neighbors Out parameter for an array of indices of neighboring nodes.
  * @return Status code indicating success or failure.
  */
-int matrix_get_neighbors_by_label(const matrix_t * graph,
-                                  const char *     node_label,
-                                  size_t *         num_neighbors,
-                                  size_t **        neighbors);
+int matrix_get_neighbors_by_label(const matrix_t *graph,
+                                  const char *node_label,
+                                  size_t *num_neighbors,
+                                  size_t **neighbors);
 
 /**
  * @brief Returns a deep copy of a graph, without affecting the original.
@@ -185,7 +186,7 @@ int matrix_get_neighbors_by_label(const matrix_t * graph,
  * @param graph Pointer to the graph.
  * @return A new copy of the graph
  */
-matrix_t * matrix_copy(const matrix_t * graph);
+matrix_t *matrix_copy(const matrix_t *graph);
 
 /**
  * @brief Performs a Breadth-First Search (BFS) starting from a given node.
@@ -197,9 +198,9 @@ matrix_t * matrix_copy(const matrix_t * graph);
  *                     the node's data and its label.
  * @return Status code indicating success or failure.
  */
-int matrix_bfs(const matrix_t * graph,
-               const char *     start_label,
-               ACTION_F         visit_action);
+int matrix_bfs(const matrix_t *graph,
+               const char *start_label,
+               ACTION_F visit_action);
 
 /**
  * @brief Performs a Depth-First Search (DFS) starting from a given node.
@@ -211,9 +212,9 @@ int matrix_bfs(const matrix_t * graph,
  *                     the node's data and its label.
  * @return Status code indicating success or failure.
  */
-int matrix_dfs(const matrix_t * graph,
-               const char *     start_label,
-               ACTION_F         visit_action);
+int matrix_dfs(const matrix_t *graph,
+               const char *start_label,
+               ACTION_F visit_action);
 
 /**
  * @brief Performs a flood fill starting from a given node, applying an action
@@ -227,10 +228,10 @@ int matrix_dfs(const matrix_t * graph,
  * filled. This might involve setting a value or marking the node.
  * @return Status code indicating success or failure.
  */
-int matrix_flood_fill(matrix_t *   graph,
-                      const char * start_label,
-                      PREDICATE_F  predicate,
-                      ACTION_F     fill_action);
+int matrix_flood_fill(matrix_t *graph,
+                      const char *start_label,
+                      PREDICATE_F predicate,
+                      ACTION_F fill_action);
 
 /**
  * @brief Finds the shortest path between two nodes in a graph using Dijkstra's
@@ -248,12 +249,12 @@ int matrix_flood_fill(matrix_t *   graph,
  * populating `path`, `path_length`, and `total_weight` with the shortest path
  * information.
  */
-int matrix_dijkstra_shortest_path(const matrix_t * graph,
-                                  const char *     start_label,
-                                  const char *     target_label,
-                                  char ***         path,
-                                  int *            path_length,
-                                  size_t *         total_weight);
+int matrix_dijkstra_shortest_path(const matrix_t *graph,
+                                  const char *start_label,
+                                  const char *target_label,
+                                  char ***path,
+                                  int *path_length,
+                                  size_t *total_weight);
 
 /**
  * @brief Finds the shortest path between two nodes in a graph using the A*
@@ -275,13 +276,13 @@ int matrix_dijkstra_shortest_path(const matrix_t * graph,
  * populating `path`, `path_length`, and `total_weight` with the shortest path
  * information.
  */
-int matrix_astar_shortest_path(const matrix_t * graph,
-                               const char *     start_label,
-                               const char *     target_label,
-                               HEURISTIC_F      heuristic,
-                               char ***         path,
-                               int *            path_length,
-                               size_t *         total_weight);
+int matrix_astar_shortest_path(const matrix_t *graph,
+                               const char *start_label,
+                               const char *target_label,
+                               HEURISTIC_F heuristic,
+                               char ***path,
+                               int *path_length,
+                               size_t *total_weight);
 
 /**
  * @brief Prints the graph's adjacency matrix and node labels to standard
@@ -289,36 +290,36 @@ int matrix_astar_shortest_path(const matrix_t * graph,
  *
  * @param graph Pointer to the graph.
  */
-void matrix_print(const matrix_t * graph);
+void matrix_print(const matrix_t *graph);
 
 // Secondary API functions
 
-int matrix_add_edge_by_index(matrix_t * graph,
-                             size_t     src_index,
-                             size_t     dst_index,
-                             size_t     weight);
+int matrix_add_edge_by_index(matrix_t *graph,
+                             size_t src_index,
+                             size_t dst_index,
+                             size_t weight);
 
-int matrix_remove_edge_by_index(matrix_t * graph,
-                                size_t     src_index,
-                                size_t     dst_index);
+int matrix_remove_edge_by_index(matrix_t *graph,
+                                size_t src_index,
+                                size_t dst_index);
 
-int matrix_set_edge_weight_by_index(matrix_t * graph,
-                                    size_t     src_index,
-                                    size_t     dst_index,
-                                    size_t     edge_weight);
+int matrix_set_edge_weight_by_index(matrix_t *graph,
+                                    size_t src_index,
+                                    size_t dst_index,
+                                    size_t edge_weight);
 
-int matrix_get_edge_weight_by_index(matrix_t * graph,
-                                    size_t     src_index,
-                                    size_t     dst_index,
-                                    size_t *   edge_weight);
+int matrix_get_edge_weight_by_index(matrix_t *graph,
+                                    size_t src_index,
+                                    size_t dst_index,
+                                    size_t *edge_weight);
 
-int matrix_has_edge_by_index(const matrix_t * graph,
-                             size_t           src_index,
-                             size_t           dst_index);
+int matrix_has_edge_by_index(const matrix_t *graph,
+                             size_t src_index,
+                             size_t dst_index);
 
-int matrix_get_neighbors_by_index(const matrix_t * graph,
-                                  size_t           node_index,
-                                  size_t **        neighbors);
+int matrix_get_neighbors_by_index(const matrix_t *graph,
+                                  size_t node_index,
+                                  size_t **neighbors);
 #endif /* _ADJACENCY_MATRIX_H */
 
 /*** end of file ***/
diff --git a/libraries/DSA/linked_list/include/linked_list.h b/libraries/DSA/linked_list/include/linked_list.h
index b32cb68..aa9c91e 100644
--- a/libraries/DSA/linked_list/include/linked_list.h
+++ b/libraries/DSA/linked_list/include/linked_list.h
@@ -8,7 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#include "callback_types.h"
+#include "comparisons.h"
 
 /**
  * @brief structure of a list node
@@ -225,7 +225,7 @@ void * list_pick_random_item(list_t * list);
  * searched for
  * @return pointer to node found on success, NULL on failure
  */
-void * list_find_first_occurrence(list_t * list, void * search_data);
+void * list_find_first_occurrence(list_t * list, void ** search_data);
 
 /**
  * @brief find the first occurrance of a node containing the search_data as
@@ -237,7 +237,7 @@ void * list_find_first_occurrence(list_t * list, void * search_data);
  *                    for
  * @return pointer to list of all found occurrecnces on success, NULL on failure
  */
-list_t * list_find_all_occurrences(list_t * list, void * search_data);
+list_t * list_find_all_occurrences(list_t * list, void ** search_data);
 
 /**
  * @brief sort list as per user defined compare function
diff --git a/libraries/DSA/linked_list/src/linked_list.c b/libraries/DSA/linked_list/src/linked_list.c
index c520b50..c3b235e 100644
--- a/libraries/DSA/linked_list/src/linked_list.c
+++ b/libraries/DSA/linked_list/src/linked_list.c
@@ -29,7 +29,7 @@ static list_node_t * find_node(list_t * list, void * data);
  * @param list Pointer to the linked list.
  * @param node Pointer to the node to be removed.
  */
-static int remove_node(list_t * list, list_node_t * node);
+static void remove_node(list_t * list, list_node_t * node);
 
 /**
  * @brief Splits a list into two equal halves
@@ -321,6 +321,7 @@ END:
 void * list_pop_position(list_t * list, uint32_t position)
 {
     list_node_t * current = NULL;
+    list_node_t * temp    = NULL;
     void *        data    = NULL;
 
     if (NULL == list)
@@ -338,36 +339,39 @@ void * list_pop_position(list_t * list, uint32_t position)
     // Handle special cases for head and tail
     if (0 == position)
     {
-        data = list_pop_head(list);
+        temp = list_pop_head(list);
         goto END;
     }
-    if (position == list->size - 1)
+    if (position == list->size)
     {
-        data = list_pop_tail(list);
+        temp = list_pop_tail(list);
         goto END;
     }
 
     // Navigate to the specified position
     current = list->head;
-    for (uint32_t idx = 0; idx < position; idx++)
+    for (uint32_t idx = 0; idx < position - 1; idx++)
     {
         current = current->next;
     }
 
     // Pop the node at the specified position
-    data                = current->data;
+    temp = current;
+    data = temp->data;
+
     current->prev->next = current->next;
     if (NULL != current->next)
     {
         current->next->prev = current->prev;
     }
 
+    temp->prev = NULL;
+    temp->next = NULL;
+
     list->size--;
 
-    list->custom_free(current->data);
-    current->data = NULL;
-    free(current);
-    current = NULL;
+    free(temp);
+    temp = NULL;
 
 END:
     return data;
@@ -375,19 +379,20 @@ END:
 
 int list_remove_head(list_t * list)
 {
-    int    exit_code = E_FAILURE;
-    void * data      = NULL;
+    int           exit_code      = E_FAILURE;
+    list_node_t * node_to_remove = NULL;
 
     if (NULL == list)
     {
         print_error("List is empty.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
-    data = list_pop_head(list);
-    list->custom_free(data);
-    data = NULL;
+    node_to_remove = list_pop_head(list);
+    list->custom_free(node_to_remove->data);
+    node_to_remove->data = NULL;
+    free(node_to_remove);
+    node_to_remove = NULL;
 
     exit_code = E_SUCCESS;
 END:
@@ -396,19 +401,20 @@ END:
 
 int list_remove_tail(list_t * list)
 {
-    int    exit_code = E_FAILURE;
-    void * data      = NULL;
+    int           exit_code      = E_FAILURE;
+    list_node_t * node_to_remove = NULL;
 
     if (NULL == list)
     {
         print_error("List is empty.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
-    data = list_pop_tail(list);
-    list->custom_free(data);
-    data = NULL;
+    node_to_remove = list_pop_tail(list);
+    list->custom_free(node_to_remove->data);
+    node_to_remove->data = NULL;
+    free(node_to_remove);
+    node_to_remove = NULL;
 
     exit_code = E_SUCCESS;
 END:
@@ -417,13 +423,12 @@ END:
 
 int list_remove_position(list_t * list, uint32_t position)
 {
-    int    exit_code = E_FAILURE;
-    void * data      = NULL;
+    int           exit_code      = E_FAILURE;
+    list_node_t * node_to_remove = NULL;
 
     if (NULL == list)
     {
         print_error("List is empty.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
@@ -433,9 +438,11 @@ int list_remove_position(list_t * list, uint32_t position)
         goto END;
     }
 
-    data = list_pop_position(list, position);
-    list->custom_free(data);
-    data = NULL;
+    node_to_remove = list_pop_position(list, position);
+    list->custom_free(node_to_remove->data);
+    node_to_remove->data = NULL;
+    free(node_to_remove);
+    node_to_remove = NULL;
 
     exit_code = E_SUCCESS;
 END:
@@ -444,29 +451,23 @@ END:
 
 void * list_peek_head(list_t * list)
 {
-    void * data = NULL;
+    list_node_t * node = NULL;
 
     if (NULL == list)
     {
-        print_error("list_peek_head(): NULL argument passed.");
-        goto END;
-    }
-
-    if (NULL == list->head)
-    {
-        print_error("list_peek_head(): Empty list.");
+        print_error("NULL argument passed.");
         goto END;
     }
 
-    data = list->head->data;
+    node = list->head;
 
 END:
-    return data;
+    return node->data;
 }
 
 void * list_peek_tail(list_t * list)
 {
-    void * data = NULL;
+    list_node_t * node = NULL;
 
     if (NULL == list)
     {
@@ -474,22 +475,15 @@ void * list_peek_tail(list_t * list)
         goto END;
     }
 
-    if (NULL == list->tail)
-    {
-        print_error("list_peek_tail(): Empty list.");
-        goto END;
-    }
-
-    data = list->tail->data;
+    node = list->tail;
 
 END:
-    return data;
+    return node->data;
 }
 
 void * list_peek_position(list_t * list, uint32_t position)
 {
-    list_node_t * current = NULL;
-    void *        data    = NULL;
+    list_node_t * current_node = NULL;
 
     if (NULL == list)
     {
@@ -497,28 +491,20 @@ void * list_peek_position(list_t * list, uint32_t position)
         goto END;
     }
 
-    if (0 == list->size)
-    {
-        print_error("list_peek_position(): Empty list.");
-        goto END;
-    }
-
     if (position >= list->size)
     {
         print_error("Position out of bounds.");
         goto END;
     }
 
-    current = list->head;
+    current_node = list->head;
     for (uint32_t idx = 0; idx < position; idx++)
     {
-        current = current->next;
+        current_node = current_node->next;
     }
 
-    data = current->data;
-
 END:
-    return data;
+    return current_node->data;
 }
 
 int list_remove_data(list_t * list, void * data_p)
@@ -529,22 +515,13 @@ int list_remove_data(list_t * list, void * data_p)
     if ((NULL == list) || (NULL == data_p))
     {
         print_error("NULL argument passed.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
     node_to_remove = find_node(list, data_p);
-    if (NULL == node_to_remove)
+    if (NULL != node_to_remove)
     {
-        print_error("list_remove_data(): Node not found.");
-        goto END;
-    }
-
-    exit_code = remove_node(list, node_to_remove);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("list_remove_data(): Unable to remove node.");
-        goto END;
+        remove_node(list, node_to_remove);
     }
 
     exit_code = E_SUCCESS;
@@ -560,7 +537,6 @@ int list_foreach_call(list_t * list, ACT_F action_function)
     if ((NULL == list) || (NULL == action_function))
     {
         print_error("NULL argument passed.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
@@ -568,7 +544,7 @@ int list_foreach_call(list_t * list, ACT_F action_function)
 
     for (size_t idx = 0; idx < list->size; idx++)
     {
-        action_function(current_node->data);
+        action_function(current_node);
         current_node = current_node->next;
     }
 
@@ -577,7 +553,7 @@ END:
     return exit_code;
 }
 
-void * list_find_first_occurrence(list_t * list, void * search_data)
+void * list_find_first_occurrence(list_t * list, void ** search_data)
 {
     list_node_t * current_node = NULL;
 
@@ -591,7 +567,9 @@ void * list_find_first_occurrence(list_t * list, void * search_data)
 
     for (size_t idx = 0; idx < list->size; idx++)
     {
-        if (EQUAL == list->compare_func(search_data, current_node->data))
+        if (EQUAL ==
+            (list->compare_func(*search_data,
+                                ((list_node_t *)(current_node->data))->data)))
         {
             goto END;
         }
@@ -601,7 +579,7 @@ void * list_find_first_occurrence(list_t * list, void * search_data)
 
     current_node = NULL; // Set back to NULL if no match was found
 END:
-    return current_node;
+    return current_node->data;
 }
 
 bool list_contains(list_t * list, void * data_p)
@@ -636,12 +614,10 @@ void * list_pick_random_item(list_t * list)
     int           exit_code    = E_FAILURE;
     list_node_t * node_p       = NULL;
     int           random_index = 0;
-    void *        data         = NULL;
 
     if (NULL == list)
     {
         print_error("list_pick_random_item(): NULL argument passed.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
@@ -672,13 +648,11 @@ void * list_pick_random_item(list_t * list)
         goto END;
     }
 
-    data = node_p->data;
-
 END:
-    return data;
+    return node_p->data;
 }
 
-list_t * list_find_all_occurrences(list_t * list, void * search_data)
+list_t * list_find_all_occurrences(list_t * list, void ** search_data)
 {
     list_t *      new_list     = NULL;
     list_node_t * current_node = NULL;
@@ -708,7 +682,7 @@ list_t * list_find_all_occurrences(list_t * list, void * search_data)
     // Iterate over the whole list and store any matches in 'new_list'
     for (size_t idx = 0; idx < list->size; idx++)
     {
-        if (EQUAL == (list->compare_func(search_data, current_node->data)))
+        if (ERROR != (list->compare_func(search_data, current_node)))
         {
             check = list_push_head(new_list, current_node->data);
             if (E_SUCCESS != check)
@@ -718,11 +692,8 @@ list_t * list_find_all_occurrences(list_t * list, void * search_data)
                 goto END;
             }
         }
-        current_node = current_node->next;
     }
 
-    printf("new list size = %d\n", new_list->size);
-
 END:
     return new_list;
 }
@@ -731,17 +702,12 @@ int list_sort(list_t * list)
 {
     int exit_code = E_FAILURE;
 
-    if (NULL == list)
+    if (NULL != list)
     {
-        print_error("list_sort(): NULL argument passed.");
-        exit_code = E_NULL_POINTER;
-        goto END;
+        merge_sort(&(list->head), list->compare_func);
+        exit_code = E_SUCCESS;
     }
 
-    merge_sort(&(list->head), list->compare_func);
-
-    exit_code = E_SUCCESS;
-END:
     return exit_code;
 }
 
@@ -854,20 +820,15 @@ static list_node_t * find_node(list_t * list, void * data)
         current_node = current_node->next;
     }
 
-    // Node not found
-    current_node = NULL;
 END:
     return current_node;
 }
 
-static int remove_node(list_t * list, list_node_t * node)
+static void remove_node(list_t * list, list_node_t * node)
 {
-    int exit_code = E_FAILURE;
-
     if ((NULL == list) || (NULL == node))
     {
         print_error("NULL argument passed.");
-        exit_code = E_NULL_POINTER;
         goto END;
     }
 
@@ -896,9 +857,8 @@ static int remove_node(list_t * list, list_node_t * node)
 
     list->size--;
 
-    exit_code = E_SUCCESS;
 END:
-    return exit_code;
+    return;
 }
 
 static void split(list_node_t *  head,
diff --git a/libraries/DSA/linked_list/tests/linked_list_tests.c b/libraries/DSA/linked_list/tests/linked_list_tests.c
index 9c5d4ce..456a733 100644
--- a/libraries/DSA/linked_list/tests/linked_list_tests.c
+++ b/libraries/DSA/linked_list/tests/linked_list_tests.c
@@ -13,12 +13,6 @@ list_t * test_list = NULL;
 
 int data[DATA_ARR_LENGTH] = { 44, 51, 77, 14, 68, 41, 46, 18, 72, 53 };
 
-void custom_action(void * data)
-{
-    int * value = (int *)data;
-    (*value)++;
-}
-
 void custom_free(void * data)
 {
     (void)data;
@@ -365,416 +359,218 @@ void test_list_pop_tail_multiple(void)
 
 void test_list_pop_position_null_list(void)
 {
-    void * result = NULL;
-
-    result = list_pop_position(NULL, 0);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_pop_position(void)
 {
-    int    exit_code = E_FAILURE;
-    void * result    = NULL;
-
-    exit_code = list_push_position(test_list, &data[0], 0); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_position(test_list, &data[1], 1); // [44, 51]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_position(test_list, &data[2], 2); // [44, 51, 77]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    result = list_pop_position(test_list, 1); // [44, 77]
-    CU_ASSERT_PTR_NOT_NULL(result);
-    CU_ASSERT_EQUAL(*(int *)result, data[1]);
-
-    result = list_pop_position(test_list, 0); // [77]
-    CU_ASSERT_PTR_NOT_NULL(result);
-    CU_ASSERT_EQUAL(*(int *)result, data[0]);
-
-    result = list_pop_position(test_list, 0); // []
-    CU_ASSERT_PTR_NOT_NULL(result);
-    CU_ASSERT_EQUAL(*(int *)result, data[2]);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_head_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_remove_head(NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_head(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_push_head(test_list, &data[0]); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_head(test_list, &data[1]); // [51, 44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = list_remove_head(test_list); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(*(int *)list_peek_head(test_list), data[0]);
-
-    exit_code = list_remove_head(test_list); // []
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_PTR_NULL(list_peek_head(test_list));
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_tail_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_remove_tail(NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_tail(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_push_head(test_list, &data[0]); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_head(test_list, &data[1]); // [51, 44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = list_remove_tail(test_list); // [51]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(*(int *)list_peek_tail(test_list), data[1]);
-
-    exit_code = list_remove_tail(test_list); // []
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_PTR_NULL(list_peek_tail(test_list));
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_position_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_remove_position(NULL, 0);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_position(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_push_position(test_list, &data[0], 0); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_position(test_list, &data[1], 1); // [44, 51]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_position(test_list, &data[2], 2); // [44, 51, 77]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = list_remove_position(test_list, 1); // [44, 77]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(*(int *)list_peek_position(test_list, 1), data[2]);
-
-    exit_code = list_remove_position(test_list, 0); // [77]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(*(int *)list_peek_position(test_list, 0), data[2]);
-
-    exit_code = list_remove_position(test_list, 0); // []
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_PTR_NULL(list_peek_position(test_list, 0));
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_peek_head_null_list(void)
 {
-    void * result = NULL;
-
-    result = list_peek_head(NULL);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_peek_head(void)
 {
-    int    exit_code = E_FAILURE;
-    void * result    = NULL;
-
-    exit_code = list_push_head(test_list, &data[0]); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    result = list_peek_head(test_list);
-    CU_ASSERT_EQUAL(*(int *)result, data[0]);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_peek_tail_null_list(void)
 {
-    void * result = NULL;
-
-    result = list_peek_tail(NULL);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_peek_tail(void)
 {
-    int    exit_code = E_FAILURE;
-    void * result    = NULL;
-
-    exit_code = list_push_head(test_list, &data[0]); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    result = list_peek_tail(test_list);
-    CU_ASSERT_EQUAL(*(int *)result, data[0]);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_peek_position_null_list(void)
 {
-    void * result = NULL;
-
-    result = list_peek_position(NULL, 0);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_peek_position(void)
 {
-    int    exit_code = E_FAILURE;
-    void * result    = NULL;
-
-    exit_code = list_push_position(test_list, &data[0], 0); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_position(test_list, &data[1], 1); // [44, 51]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_position(test_list, &data[2], 2); // [44, 51, 77]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    result = list_peek_position(test_list, 1);
-    CU_ASSERT_EQUAL(*(int *)result, data[1]);
-
-    result = list_peek_position(test_list, 0);
-    CU_ASSERT_EQUAL(*(int *)result, data[0]);
-
-    result = list_peek_position(test_list, 2);
-    CU_ASSERT_EQUAL(*(int *)result, data[2]);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_data_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_remove_data(NULL, &data[0]);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_data_null_data_p(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_remove_data(test_list, NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_remove_data(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_push_head(test_list, &data[0]); // [44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    exit_code = list_push_head(test_list, &data[1]); // [51, 44]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = list_remove_data(test_list, &data[0]); // [51]
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(*(int *)list_peek_head(test_list), data[1]);
-
-    exit_code = list_remove_data(test_list, &data[1]); // []
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_PTR_NULL(list_peek_head(test_list));
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_foreach_call_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_foreach_call(NULL, NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_foreach_call(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_push_head(test_list, &data[0]);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    exit_code = list_foreach_call(test_list, custom_action);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    CU_ASSERT_EQUAL(data[0], 45);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_contains_null_list(void)
 {
-    bool result = false;
-
-    result = list_contains(NULL, &data[0]);
-    CU_ASSERT_FALSE(result);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_contains_null_data_p(void)
 {
-    bool result = false;
-
-    result = list_contains(test_list, NULL);
-    CU_ASSERT_FALSE(result);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_contains(void)
 {
-    bool result = false;
-
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    result = list_contains(test_list, &data[0]);
-    CU_ASSERT_TRUE(result);
-
-    result = list_contains(test_list, &data[2]);
-    CU_ASSERT_FALSE(result);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_pick_random_item_null_list(void)
 {
-    void * result = NULL;
-
-    result = list_pick_random_item(NULL);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_pick_random_item(void)
 {
-    void * result = NULL;
-
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    result = list_pick_random_item(test_list);
-    CU_ASSERT_PTR_NOT_NULL(result);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_find_first_occurrence_null_list(void)
 {
-    void * result = NULL;
-
-    result = list_find_first_occurrence(NULL, &data[0]);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_find_first_occurrence_null_search_data(void)
 {
-    void * result = NULL;
-
-    result = list_find_first_occurrence(test_list, NULL);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_find_first_occurrence(void)
 {
-    void * result = NULL;
-
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    result = list_find_first_occurrence(test_list, &data[0]);
-    CU_ASSERT_PTR_NOT_NULL(result);
-    CU_ASSERT_EQUAL(*(int *)(((list_node_t *)result)->data), data[0]);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_find_all_occurrences_null_list(void)
 {
-    list_t * result = NULL;
-
-    result = list_find_all_occurrences(NULL, &data[0]);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_find_all_occurrences_null_search_data(void)
 {
-    list_t * result = NULL;
-
-    result = list_find_all_occurrences(test_list, NULL);
-    CU_ASSERT_PTR_EQUAL(result, NULL);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_find_all_occurrences(void)
 {
-    list_t * result = NULL;
-
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    result = list_find_all_occurrences(test_list, &data[0]);
-    CU_ASSERT_PTR_NOT_NULL(result);
-    CU_ASSERT_EQUAL(result->size, 2);
-
-    list_delete(&result);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_sort_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_sort(NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_sort(void)
 {
-    int exit_code = E_FAILURE;
-
-    list_push_head(test_list, &data[2]);
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    exit_code = list_sort(test_list);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-
-    CU_ASSERT_EQUAL(*(int *)list_peek_head(test_list), data[0]);
-    CU_ASSERT_EQUAL(*(int *)list_peek_tail(test_list), data[2]);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_clear_null_list(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_clear(NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_clear(void)
 {
-    int exit_code = E_FAILURE;
-
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    exit_code = list_clear(test_list);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_EQUAL(test_list->size, 0);
-    CU_ASSERT_PTR_NULL(list_peek_head(test_list));
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_delete_null_list_address(void)
 {
-    int exit_code = E_FAILURE;
-
-    exit_code = list_delete(NULL);
-    CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 void test_list_delete(void)
 {
-    int exit_code = E_FAILURE;
-
-    list_push_head(test_list, &data[0]);
-    list_push_head(test_list, &data[1]);
-
-    exit_code = list_delete(&test_list);
-    CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
-    CU_ASSERT_PTR_NULL(test_list);
+    // TODO: Add test logic here
+    CU_FAIL()
 }
 
 static CU_TestInfo linked_list_tests[] = {
@@ -802,46 +598,46 @@ static CU_TestInfo linked_list_tests[] = {
     { "pop_tail_empty", test_list_pop_tail_empty },
     { "pop_tail_single", test_list_pop_tail_single },
     { "pop_tail_multiple", test_list_pop_tail_multiple },
-    { "pop_position_null_list", test_list_pop_position_null_list },
-    { "pop_position", test_list_pop_position },
-    { "remove_head_null_list", test_list_remove_head_null_list },
-    { "remove_head", test_list_remove_head },
-    { "remove_tail_null_list", test_list_remove_tail_null_list },
-    { "remove_tail", test_list_remove_tail },
-    { "remove_position_null_list", test_list_remove_position_null_list },
-    { "remove_position", test_list_remove_position },
-    { "peek_head_null_list", test_list_peek_head_null_list },
-    { "peek_head", test_list_peek_head },
-    { "peek_tail_null_list", test_list_peek_tail_null_list },
-    { "peek_tail", test_list_peek_tail },
-    { "peek_position_null_list", test_list_peek_position_null_list },
-    { "peek_position", test_list_peek_position },
-    { "remove_data_null_list", test_list_remove_data_null_list },
-    { "remove_data_null_data_p", test_list_remove_data_null_data_p },
-    { "remove_data", test_list_remove_data },
-    { "foreach_call_null_list", test_list_foreach_call_null_list },
-    { "foreach_call", test_list_foreach_call },
-    { "contains_null_list", test_list_contains_null_list },
-    { "contains_null_data_p", test_list_contains_null_data_p },
-    { "contains", test_list_contains },
-    { "pick_random_item_null_list", test_list_pick_random_item_null_list },
-    { "pick_random_item", test_list_pick_random_item },
-    { "find_first_occurrence_null_list",
-      test_list_find_first_occurrence_null_list },
-    { "find_first_occurrence_null_search_data",
-      test_list_find_first_occurrence_null_search_data },
-    { "find_first_occurrence", test_list_find_first_occurrence },
-    { "find_all_occurrences_null_list",
-      test_list_find_all_occurrences_null_list },
-    { "find_all_occurrences_null_search_data",
-      test_list_find_all_occurrences_null_search_data },
-    { "find_all_occurrences", test_list_find_all_occurrences },
-    { "sort_null_list", test_list_sort_null_list },
-    { "sort", test_list_sort },
-    { "clear_null_list", test_list_clear_null_list },
-    { "clear", test_list_clear },
-    { "delete_null_list_address", test_list_delete_null_list_address },
-    { "delete", test_list_delete },
+    // { "pop_position_null_list", test_list_pop_position_null_list },
+    // { "pop_position", test_list_pop_position },
+    // { "remove_head_null_list", test_list_remove_head_null_list },
+    // { "remove_head", test_list_remove_head },
+    // { "remove_tail_null_list", test_list_remove_tail_null_list },
+    // { "remove_tail", test_list_remove_tail },
+    // { "remove_position_null_list", test_list_remove_position_null_list },
+    // { "remove_position", test_list_remove_position },
+    // { "peek_head_null_list", test_list_peek_head_null_list },
+    // { "peek_head", test_list_peek_head },
+    // { "peek_tail_null_list", test_list_peek_tail_null_list },
+    // { "peek_tail", test_list_peek_tail },
+    // { "peek_position_null_list", test_list_peek_position_null_list },
+    // { "peek_position", test_list_peek_position },
+    // { "remove_data_null_list", test_list_remove_data_null_list },
+    // { "remove_data_null_data_p", test_list_remove_data_null_data_p },
+    // { "remove_data", test_list_remove_data },
+    // { "foreach_call_null_list", test_list_foreach_call_null_list },
+    // { "foreach_call", test_list_foreach_call },
+    // { "contains_null_list", test_list_contains_null_list },
+    // { "contains_null_data_p", test_list_contains_null_data_p },
+    // { "contains", test_list_contains },
+    // { "pick_random_item_null_list", test_list_pick_random_item_null_list },
+    // { "pick_random_item", test_list_pick_random_item },
+    // { "find_first_occurrence_null_list",
+    //   test_list_find_first_occurrence_null_list },
+    // { "find_first_occurrence_null_search_data",
+    //   test_list_find_first_occurrence_null_search_data },
+    // { "find_first_occurrence", test_list_find_first_occurrence },
+    // { "find_all_occurrences_null_list",
+    //   test_list_find_all_occurrences_null_list },
+    // { "find_all_occurrences_null_search_data",
+    //   test_list_find_all_occurrences_null_search_data },
+    // { "find_all_occurrences", test_list_find_all_occurrences },
+    // { "sort_null_list", test_list_sort_null_list },
+    // { "sort", test_list_sort },
+    // { "clear_null_list", test_list_clear_null_list },
+    // { "clear", test_list_clear },
+    // { "delete_null_list_address", test_list_delete_null_list_address },
+    // { "delete", test_list_delete },
     CU_TEST_INFO_NULL
 };
 
diff --git a/libraries/DSA/queue/include/queue.h b/libraries/DSA/queue/include/queue.h
index 4f7e370..ed6ad22 100644
--- a/libraries/DSA/queue/include/queue.h
+++ b/libraries/DSA/queue/include/queue.h
@@ -1,7 +1,6 @@
 #ifndef _QUEUE_H
 #define _QUEUE_H
 
-#include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -13,14 +12,13 @@
  */
 typedef struct queue_node_t
 {
-    void *                data;
-    struct queue_node_t * next;
+    void * data;
 } queue_node_t;
 
 /**
- * @brief A pointer to a user-defined free function. This is used to free
- *        memory allocated for queue data. For simple data types, this is
- *        just a pointer to the standard free function. More complex structs
+ * @brief A pointer to a user-defined free function.  This is used to free
+ *        memory allocated for queue data.  For simple data types, this is
+ *        just a pointer to the standard free function.  More complex structs
  *        stored in queues may require a function that calls free on multiple
  *        components.
  *
@@ -30,36 +28,45 @@ typedef void (*FREE_F)(void *);
 /**
  * @brief structure of a queue object
  *
+ * @param capacity is the number of nodes the queue can hold
  * @param currentsz is the number of nodes the queue is currently storing
- * @param head is the pointer to the front of the queue
- * @param tail is the pointer to the rear of the queue
  * @param customfree is a FREE_F pointer to a user defined free function
+ * @param arr is the array containing the queue node pointers
  *
  */
 typedef struct queue_t
 {
-    uint32_t       currentsz;
-    queue_node_t * head;
-    queue_node_t * tail;
-    FREE_F         customfree;
+    uint32_t        capacity;
+    uint32_t        currentsz;
+    FREE_F          customfree;
+    queue_node_t ** arr;
 } queue_t;
 
 /**
  * @brief creates a new queue
  *
- * @param customfree pointer to user defined free function
+ * @param capacity max number of nodes the queue will hold
+ * @param custmfree pointer to user defined free function
  * @note if the user passes in NULL, the queue should default to using free()
- * @returns the queue on success, NULL on failure
+ * @returns the 0 on success, non-zero value on failure
  */
-queue_t * queue_init(FREE_F customfree);
+queue_t * queue_init(uint32_t capacity, FREE_F customfree);
 
 /**
- * @brief checks if the queue is empty
+ * @brief verifies that queue isn't full
  *
  * @param queue pointer queue object
- * @return true if empty, false otherwise
+ * @return 0 on success, non-zero value on failure
  */
-bool queue_is_empty(queue_t * queue);
+int queue_fullcheck(queue_t * queue);
+
+/**
+ * @brief verifies that queue isn't empty
+ *
+ * @param queue pointer queue object
+ * @return 0 on success, non-zero value on failure
+ */
+int queue_emptycheck(queue_t * queue);
 
 /**
  * @brief pushes a new node into the queue
@@ -73,18 +80,18 @@ int queue_enqueue(queue_t * queue, void * data);
 /**
  * @brief pops the front node out of the queue
  *
- * @param queue pointer to data to dequeue
- * @return the data of the front node on success or NULL on failure
+ * @param queue pointer to queue pointer to pop the node off of
+ * @return the 0 on success, non-zero value on failure
  */
-void * queue_dequeue(queue_t * queue);
+queue_node_t * queue_dequeue(queue_t * queue);
 
 /**
  * @brief get the data from the node at the front of the queue without popping
  *
- * @param queue pointer to data to peek
+ * @param queue pointer to queue pointer to peek
  * @return the pointer to the head on success or NULL for failure
  */
-void * queue_peek(queue_t * queue);
+queue_node_t * queue_peek(queue_t * queue);
 
 /**
  * @brief clear all nodes out of a queue
@@ -100,6 +107,6 @@ int queue_clear(queue_t * queue);
  * @param queue_addr pointer to address of queue to be destroyed
  * @return the 0 on success, non-zero value on failure
  */
-void queue_destroy(queue_t ** queue_addr);
+int queue_destroy(queue_t ** queue_addr);
 
 #endif
diff --git a/libraries/DSA/queue/src/queue.c b/libraries/DSA/queue/src/queue.c
index 1405a2c..08a5797 100644
--- a/libraries/DSA/queue/src/queue.c
+++ b/libraries/DSA/queue/src/queue.c
@@ -1,7 +1,7 @@
 #include "queue.h"
 #include "utilities.h"
 
-queue_t * queue_init(FREE_F customfree)
+queue_t * queue_init(uint32_t capacity, FREE_F customfree)
 {
     queue_t * queue = calloc(1, sizeof(queue_t));
     if (NULL == queue)
@@ -10,34 +10,65 @@ queue_t * queue_init(FREE_F customfree)
         goto END;
     }
 
-    queue->currentsz  = 0;
-    queue->head       = NULL;
-    queue->tail       = NULL;
+    queue->capacity  = capacity;
+    queue->currentsz = 0;
+    queue->arr       = calloc(capacity, sizeof(queue_node_t *));
+    if (NULL == queue->arr)
+    {
+        print_error("CMR failure.");
+        free(queue);
+        queue = NULL;
+        goto END;
+    }
+
     queue->customfree = (NULL == customfree) ? free : customfree;
 
 END:
     return queue;
 }
 
-bool queue_is_empty(queue_t * queue)
+int queue_fullcheck(queue_t * queue)
 {
-    bool result = false;
+    int exit_code = E_FAILURE;
 
-    if (0 == queue->currentsz)
+    if (NULL == queue)
+    {
+        print_error("NULL argument passed.");
+        goto END;
+    }
+
+    if (queue->currentsz == queue->capacity)
+    {
+        exit_code = E_SUCCESS;
+    }
+
+END:
+    return exit_code;
+}
+
+int queue_emptycheck(queue_t * queue)
+{
+    int exit_code = E_FAILURE;
+
+    if (NULL == queue)
     {
-        result = true;
+        print_error("NULL argument passed.");
         goto END;
     }
 
+    if (0 == queue->currentsz)
+    {
+        exit_code = E_SUCCESS;
+    }
+
 END:
-    return result;
+    return exit_code;
 }
 
 int queue_enqueue(queue_t * queue, void * data)
 {
     int            exit_code = E_FAILURE;
     queue_node_t * new_node  = NULL;
-    bool           is_empty  = false;
 
     if ((NULL == queue) || (NULL == data))
     {
@@ -45,6 +76,12 @@ int queue_enqueue(queue_t * queue, void * data)
         goto END;
     }
 
+    if (0 == queue_fullcheck(queue))
+    {
+        print_error("Queue is full.");
+        goto END;
+    }
+
     new_node = calloc(1, sizeof(queue_node_t));
     if (NULL == new_node)
     {
@@ -53,32 +90,17 @@ int queue_enqueue(queue_t * queue, void * data)
     }
 
     new_node->data = data;
-    new_node->next = NULL;
 
-    is_empty = queue_is_empty(queue);
-    if (true == is_empty)
-    {
-        queue->head = new_node;
-        queue->tail = new_node;
-    }
-    else
-    {
-        queue->tail->next = new_node;
-        queue->tail       = new_node;
-    }
-
-    queue->currentsz++;
+    queue->arr[queue->currentsz++] = new_node;
 
     exit_code = E_SUCCESS;
 END:
     return exit_code;
 }
 
-void * queue_dequeue(queue_t * queue)
+queue_node_t * queue_dequeue(queue_t * queue)
 {
-    void *         data           = NULL;
-    queue_node_t * node_to_remove = NULL;
-    bool           is_empty       = false;
+    queue_node_t * node = NULL;
 
     if (NULL == queue)
     {
@@ -86,35 +108,30 @@ void * queue_dequeue(queue_t * queue)
         goto END;
     }
 
-    is_empty = queue_is_empty(queue);
-    if (true == is_empty)
+    if (0 == queue_emptycheck(queue))
     {
-        print_error("queue_dequeue(): Queue is empty.");
+        print_error("Queue is empty.");
         goto END;
     }
 
-    node_to_remove = queue->head;
-    data           = node_to_remove->data;
-    queue->head    = queue->head->next;
-
-    free(node_to_remove);
-    node_to_remove = NULL;
+    node = queue->arr[0];
 
-    if (queue->head == NULL)
+    for (size_t idx = 0; idx < (queue->currentsz - 1); idx++)
     {
-        queue->tail = NULL;
+        queue->arr[idx] = queue->arr[idx + 1];
     }
 
+    queue->arr[queue->currentsz - 1] = NULL;
+
     queue->currentsz--;
 
 END:
-    return data;
+    return node;
 }
 
-void * queue_peek(queue_t * queue)
+queue_node_t * queue_peek(queue_t * queue)
 {
-    void * data     = NULL;
-    bool   is_empty = false;
+    queue_node_t * node = NULL;
 
     if (NULL == queue)
     {
@@ -122,20 +139,15 @@ void * queue_peek(queue_t * queue)
         goto END;
     }
 
-    is_empty = queue_is_empty(queue);
-    if (false == is_empty)
-    {
-        data = queue->head->data;
-    }
+    node = queue->arr[0];
 
 END:
-    return data;
+    return node;
 }
 
 int queue_clear(queue_t * queue)
 {
-    int    exit_code = E_FAILURE;
-    void * data      = NULL;
+    int exit_code = E_FAILURE;
 
     if (NULL == queue)
     {
@@ -143,11 +155,13 @@ int queue_clear(queue_t * queue)
         goto END;
     }
 
-    while (false == queue_is_empty(queue))
+    while (-1 == queue_emptycheck(queue))
     {
-        data = queue_dequeue(queue);
-        queue->customfree(data);
-        data = NULL;
+        queue->customfree(queue->arr[queue->currentsz - 1]->data);
+        queue->arr[queue->currentsz - 1]->data = NULL;
+        free(queue->arr[queue->currentsz - 1]);
+        queue->arr[queue->currentsz - 1] = NULL;
+        queue->currentsz--;
     }
 
     exit_code = E_SUCCESS;
@@ -155,7 +169,7 @@ END:
     return exit_code;
 }
 
-void queue_destroy(queue_t ** queue_addr)
+int queue_destroy(queue_t ** queue_addr)
 {
     int exit_code = E_FAILURE;
 
@@ -172,11 +186,14 @@ void queue_destroy(queue_t ** queue_addr)
         goto END;
     }
 
+    free((*queue_addr)->arr);
+    (*queue_addr)->arr = NULL;
     free(*queue_addr);
     *queue_addr = NULL;
 
+    exit_code = E_SUCCESS;
 END:
-    return;
+    return exit_code;
 }
 
 /*** end of file ***/
diff --git a/libraries/DSA/queue/tests/queue_tests.c b/libraries/DSA/queue/tests/queue_tests.c
deleted file mode 100644
index aadcf18..0000000
--- a/libraries/DSA/queue/tests/queue_tests.c
+++ /dev/null
@@ -1,107 +0,0 @@
-#include <CUnit/Basic.h>
-#include <CUnit/CUnit.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdlib.h>
-
-#include "queue.h"
-
-#define QUEUE_CAPACITY 10
-
-queue_t * test_queue                = NULL;
-int       test_data[QUEUE_CAPACITY] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
-
-void custom_free(void * data)
-{
-    (void)data;
-}
-
-void setup(void)
-{
-    test_queue = queue_init(custom_free);
-}
-
-void teardown(void)
-{
-    if (NULL != test_queue)
-    {
-        queue_destroy(&test_queue);
-    }
-}
-
-void test_queue_init(void)
-{
-    CU_ASSERT_PTR_NOT_NULL_FATAL(test_queue);
-}
-
-void test_queue_is_empty(void)
-{
-    CU_ASSERT_TRUE(queue_is_empty(test_queue));
-
-    queue_enqueue(test_queue, &test_data[0]);
-    CU_ASSERT_FALSE(queue_is_empty(test_queue));
-}
-
-void test_queue_enqueue(void)
-{
-    int exit_code = queue_enqueue(test_queue, &test_data[0]);
-    CU_ASSERT_EQUAL(exit_code, 0);
-    CU_ASSERT_EQUAL(test_queue->currentsz, 1);
-}
-
-void test_queue_dequeue(void)
-{
-    queue_enqueue(test_queue, &test_data[0]);
-    queue_enqueue(test_queue, &test_data[1]);
-    int * data = (int *)queue_dequeue(test_queue);
-    CU_ASSERT_PTR_NOT_NULL_FATAL(data);
-    CU_ASSERT_EQUAL(*data, test_data[0]);
-    CU_ASSERT_EQUAL(test_queue->currentsz, 1);
-}
-
-void test_queue_peek(void)
-{
-    queue_enqueue(test_queue, &test_data[0]);
-    int * data = (int *)queue_peek(test_queue);
-    CU_ASSERT_PTR_NOT_NULL_FATAL(data);
-    CU_ASSERT_EQUAL(*data, test_data[0]);
-    CU_ASSERT_EQUAL(test_queue->currentsz, 1);
-}
-
-void test_queue_clear(void)
-{
-    for (int i = 0; i < QUEUE_CAPACITY; ++i)
-    {
-        queue_enqueue(test_queue, &test_data[i]);
-    }
-    int exit_code = queue_clear(test_queue);
-    CU_ASSERT_EQUAL(exit_code, 0);
-    CU_ASSERT_EQUAL(test_queue->currentsz, 0);
-    CU_ASSERT_TRUE(queue_is_empty(test_queue));
-}
-
-void test_queue_destroy(void)
-{
-    queue_destroy(&test_queue);
-    CU_ASSERT_PTR_NULL(test_queue);
-}
-
-static CU_TestInfo queue_tests[] = { { "queue_init", test_queue_init },
-                                     { "queue_is_empty", test_queue_is_empty },
-                                     { "queue_enqueue", test_queue_enqueue },
-                                     { "queue_dequeue", test_queue_dequeue },
-                                     { "queue_peek", test_queue_peek },
-                                     { "queue_clear", test_queue_clear },
-                                     { "queue_destroy", test_queue_destroy },
-                                     CU_TEST_INFO_NULL };
-
-CU_SuiteInfo queue_test_suite = {
-    "Queue Tests",
-    NULL,       // Suite initialization function
-    NULL,       // Suite cleanup function
-    setup,      // Suite setup function
-    teardown,   // Suite teardown function
-    queue_tests // The combined array of all tests
-};
-
-/*** end of file ***/
diff --git a/libraries/DSA/queue/tests/test_runner.c b/libraries/DSA/queue/tests/test_runner.c
deleted file mode 100644
index 8c3aaab..0000000
--- a/libraries/DSA/queue/tests/test_runner.c
+++ /dev/null
@@ -1,21 +0,0 @@
-#include <CUnit/Basic.h>
-#include <CUnit/CUnit.h>
-
-int main(void)
-{
-    CU_basic_set_mode(CU_BRM_VERBOSE);
-
-    extern CU_SuiteInfo queue_test_suite;
-
-    CU_SuiteInfo suites[] = { queue_test_suite, CU_SUITE_INFO_NULL };
-
-    CU_initialize_registry();
-
-    CU_register_suites(suites);
-
-    CU_basic_run_tests();
-
-    CU_cleanup_registry();
-}
-
-/*** end of file ***/
diff --git a/libraries/DSA/stack/src/stack.c b/libraries/DSA/stack/src/stack.c
index bffeab7..2456839 100644
--- a/libraries/DSA/stack/src/stack.c
+++ b/libraries/DSA/stack/src/stack.c
@@ -1,18 +1,18 @@
 #include "stack.h"
 #include "utilities.h"
 
-stack_t * stack_init(uint32_t capacity, FREE_F customfree)
+stack_t *stack_init(uint32_t capacity, FREE_F customfree)
 {
-    stack_t * stack = calloc(1, sizeof(stack_t));
+    stack_t *stack = calloc(1, sizeof(stack_t));
     if (NULL == stack)
     {
         print_error("CMR failure.");
         goto END;
     }
 
-    stack->capacity  = capacity;
+    stack->capacity = capacity;
     stack->currentsz = 0;
-    stack->arr       = calloc(capacity, sizeof(stack_node_t *));
+    stack->arr = calloc(capacity, sizeof(stack_node_t *));
     if (NULL == stack->arr)
     {
         print_error("CMR failure.");
@@ -27,7 +27,7 @@ END:
     return stack;
 }
 
-int stack_is_full(stack_t * stack)
+int stack_is_full(stack_t *stack)
 {
     int exit_code = E_FAILURE;
 
@@ -47,7 +47,7 @@ END:
     return exit_code;
 }
 
-int stack_is_empty(stack_t * stack)
+int stack_is_empty(stack_t *stack)
 {
     int exit_code = E_FAILURE;
 
@@ -67,10 +67,10 @@ END:
     return exit_code;
 }
 
-int stack_push(stack_t * stack, void * data)
+int stack_push(stack_t *stack, void *data)
 {
-    int            exit_code   = E_FAILURE;
-    stack_node_t * new_element = NULL;
+    int exit_code = E_FAILURE;
+    stack_node_t *new_element = NULL;
 
     if ((NULL == stack) || (NULL == data))
     {
@@ -101,9 +101,9 @@ END:
     return exit_code;
 }
 
-void * stack_pop(stack_t * stack)
+void *stack_pop(stack_t *stack)
 {
-    void * data = NULL;
+    void *data = NULL;
 
     if (NULL == stack)
     {
@@ -128,9 +128,9 @@ END:
     return data;
 }
 
-void * stack_peek(stack_t * stack)
+void *stack_peek(stack_t *stack)
 {
-    stack_node_t * element = NULL;
+    stack_node_t *element = NULL;
 
     if (NULL == stack)
     {
@@ -151,7 +151,7 @@ END:
 }
 
 // Covers 4.1.11: Make use of a function pointer to call another function
-int stack_clear(stack_t * stack)
+int stack_clear(stack_t *stack)
 {
     int exit_code = E_FAILURE;
 
@@ -176,7 +176,7 @@ END:
     return exit_code;
 }
 
-int stack_destroy(stack_t ** stack)
+int stack_destroy(stack_t **stack)
 {
     int exit_code = E_FAILURE;
 
diff --git a/libraries/DSA/vector/include/vector.h b/libraries/DSA/vector/include/vector.h
index 099a75d..dae62ee 100644
--- a/libraries/DSA/vector/include/vector.h
+++ b/libraries/DSA/vector/include/vector.h
@@ -6,7 +6,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#include "callback_types.h"
+#include "comparisons.h"
 
 /**
  * @brief A pointer to a user-defined function that gets called in the
diff --git a/libraries/Networking/tcp_server/include/event_handler.h b/libraries/Networking/tcp_server/include/event_handler.h
index 4b109e3..2b11808 100644
--- a/libraries/Networking/tcp_server/include/event_handler.h
+++ b/libraries/Networking/tcp_server/include/event_handler.h
@@ -8,43 +8,10 @@
 
 #include "server_structs.h"
 
-/**
- * @brief Handles all connections for the server.
- *
- * This function iterates through the file descriptors managed by the socket
- * manager and processes the connections. It registers new clients or handles
- * events for existing clients based on the state of the file descriptors.
- *
- * @param server Pointer to the server context.
- * @return int E_SUCCESS on success, E_FAILURE on failure.
- */
+int handle_client_event(server_context_t * server, int index);
 int handle_connections(server_context_t * server);
-
-/**
- * @brief Registers a new client connection.
- *
- * This function accepts a new client connection, sets the client socket to
- * non-blocking mode, and adds the client file descriptor to the socket manager.
- * It also logs the new connection.
- *
- * @param server Pointer to the server context.
- * @return int E_SUCCESS on success, E_FAILURE on failure.
- */
 int register_client(server_context_t * server);
 
-/**
- * @brief Handles events for a specific client.
- *
- * This function processes the events for a client by creating job arguments
- * and adding the job to the thread pool for handling. It also removes the
- * client's file descriptor from the socket manager.
- *
- * @param server Pointer to the server context.
- * @param index Index of the client file descriptor in the socket manager.
- * @return int E_SUCCESS on success, E_FAILURE on failure.
- */
-int handle_client_event(server_context_t * server, int index);
-
 #endif /* _EVENT_HANDLER_H */
 
 /*** end of file ***/
diff --git a/libraries/Networking/tcp_server/include/job_handler.h b/libraries/Networking/tcp_server/include/job_handler.h
index 34ad49d..4ce718a 100644
--- a/libraries/Networking/tcp_server/include/job_handler.h
+++ b/libraries/Networking/tcp_server/include/job_handler.h
@@ -1,8 +1,8 @@
 /**
  * @file job_handler.h
- * @brief Job handler module for processing client requests.
+ *
+ * @brief
  */
-
 #ifndef _JOB_HANDLER_H
 #define _JOB_HANDLER_H
 
@@ -11,40 +11,13 @@
 
 #include "socket_manager.h"
 
-/**
- * @struct job_arg
- * @brief Structure to hold arguments for a job.
- *
- * This structure contains the necessary arguments for processing a job,
- * including the client file descriptor, a mutex for synchronizing access to
- * the file descriptor, and a socket manager.
- */
 typedef struct job_arg
 {
     int                client_fd; // Client file descriptor.
     pthread_mutex_t *  fd_mutex;  // Mutex pointer for the client fd.
-    socket_manager_t * sock_mgr;  // Pointer to the socket manager.
+    socket_manager_t * sock_mgr;
 } job_arg_t;
 
-/**
- * @brief Process a job for a given client.
- *
- * This function processes the job for the specified client file descriptor.
- *
- * @param client_fd The file descriptor of the client.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int process_job(int client_fd);
-
-/**
- * @brief Process a client request in a separate thread.
- *
- * This function processes the client request provided in the argument, which
- * includes the client file descriptor and other necessary information.
- *
- * @param arg Pointer to the argument structure containing job details.
- * @return void* Always returns NULL.
- */
 void * process_client_request(void * arg);
 
 #endif /* _JOB_HANDLER_H */
diff --git a/libraries/Networking/tcp_server/include/server_structs.h b/libraries/Networking/tcp_server/include/server_structs.h
index 2b2c07e..410def6 100644
--- a/libraries/Networking/tcp_server/include/server_structs.h
+++ b/libraries/Networking/tcp_server/include/server_structs.h
@@ -21,11 +21,12 @@
  */
 typedef struct socket_manager
 {
-    struct pollfd * fd_arr;      // Pointer to an array of pollfd structs.
-    int             max_fds;     // Max number of file descriptors (clients).
-    int             fd_count;    // Current number of managed file descriptors.
-    int             fd_capacity; // Capacity of the array.
-    pthread_mutex_t fd_mutex;    // Mutex for the client fd.
+    struct pollfd *   fd_arr;   // Pointer to an array of pollfd structs.
+    int               max_fds;  // Max number of file descriptors (clients).
+    int               fd_count; // Current number of managed file descriptors.
+    int               fd_capacity; // Capacity of the array.
+    pthread_mutex_t   fd_mutex;
+    pthread_mutex_t * mutex_arr; // Mutex array for each possible client fd.
 } socket_manager_t;
 
 /**
diff --git a/libraries/Networking/tcp_server/include/socket_manager.h b/libraries/Networking/tcp_server/include/socket_manager.h
index 1373342..058d77b 100644
--- a/libraries/Networking/tcp_server/include/socket_manager.h
+++ b/libraries/Networking/tcp_server/include/socket_manager.h
@@ -1,96 +1,22 @@
 /**
  * @file socket_manager.h
- * @brief Socket manager module for handling socket operations.
+ *
+ * @brief
  */
-
 #ifndef _SOCKET_MANAGER_H
 #define _SOCKET_MANAGER_H
 
 #include "server_structs.h"
 
-/**
- * @brief Initialize the socket manager.
- *
- * This function initializes the socket manager, setting up the file descriptor
- * array and other necessary configurations.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- * @param server_fd The file descriptor of the server socket.
- * @param max_fds The maximum number of file descriptors.
- * @param fd_capacity The initial capacity of the file descriptor array.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int sock_mgr_init(socket_manager_t * sock_mgr,
-                  int                server_fd,
-                  int                max_fds,
-                  int                fd_capacity);
-
-/**
- * @brief Add a new file descriptor to the socket manager.
- *
- * This function adds a new file descriptor to the socket manager's file
- * descriptor array.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- * @param new_fd The new file descriptor to be added.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int sock_fd_add(socket_manager_t * sock_mgr, int new_fd);
-
-/**
- * @brief Remove a file descriptor from the socket manager.
- *
- * This function removes a file descriptor from the socket manager's file
- * descriptor array.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- * @param index The index of the file descriptor to be removed.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int sock_fd_remove(socket_manager_t * sock_mgr, int index);
-
-/**
- * @brief Increase the capacity of the file descriptor array.
- *
- * This function increases the capacity of the file descriptor array to handle
- * more file descriptors.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int sock_fd_increase_capacity(socket_manager_t * sock_mgr);
-
-/**
- * @brief Initialize the file descriptor array.
- *
- * This function initializes the file descriptor array, setting up the server
- * socket and initial configurations.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- * @param server_fd The file descriptor of the server socket.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int sock_fd_arr_init(socket_manager_t * sock_mgr, int server_fd);
-
-/**
- * @brief Close all sockets managed by the socket manager.
- *
- * This function closes all sockets in the file descriptor array and cleans up
- * resources.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- * @return int Status code, E_SUCCESS on success, or an error code on failure.
- */
-int close_all_sockets(socket_manager_t * sock_mgr);
-
-/**
- * @brief Print the file descriptor array.
- *
- * This function prints the current state of the file descriptor array for
- * debugging purposes.
- *
- * @param sock_mgr Pointer to the socket manager structure.
- */
+int  sock_mgr_init(socket_manager_t * sock_mgr,
+                   int                server_fd,
+                   int                max_fds,
+                   int                fd_capacity);
+int  sock_fd_add(socket_manager_t * sock_mgr, int new_fd);
+int  sock_fd_remove(socket_manager_t * sock_mgr, int index);
+int  sock_fd_increase_capacity(socket_manager_t * sock_mgr);
+int  sock_fd_arr_init(socket_manager_t * sock_mgr, int server_fd);
+int  close_all_sockets(socket_manager_t * sock_mgr);
 void print_fd_array(socket_manager_t * sock_mgr);
 
 #endif /* _SOCKET_MANAGER_H */
diff --git a/libraries/Networking/tcp_server/src/event_handler.c b/libraries/Networking/tcp_server/src/event_handler.c
index e32c609..6497a86 100644
--- a/libraries/Networking/tcp_server/src/event_handler.c
+++ b/libraries/Networking/tcp_server/src/event_handler.c
@@ -16,32 +16,11 @@
 
 #define POLL_ERROR_EVENTS (POLLERR | POLLHUP | POLLNVAL)
 
-/**
- * @brief Creates job arguments for handling client requests.
- *
- * This function allocates and initializes the job arguments needed for
- * processing a client request. It includes the client file descriptor, the file
- * descriptor mutex, and the socket manager.
- *
- * @param client_fd Client file descriptor.
- * @param fd_mutex Pointer to the file descriptor mutex.
- * @param sock_mgr Pointer to the socket manager.
- * @param job_args Double pointer to store the allocated job arguments.
- * @return int E_SUCCESS on success, E_FAILURE on failure.
- */
-static int create_job_args(int                client_fd,
-                           pthread_mutex_t *  fd_mutex,
-                           socket_manager_t * sock_mgr,
-                           job_arg_t **       job_args);
-
-/**
- * @brief Frees the memory allocated for job arguments.
- *
- * This function releases the memory allocated for the job arguments used
- * in processing a client request.
- *
- * @param arg Pointer to the job arguments to free.
- */
+// static int  recv_opcode(uint8_t * opcode, int client_fd);
+static int  create_job_args(int                client_fd,
+                            pthread_mutex_t *  fd_mutex,
+                            socket_manager_t * sock_mgr,
+                            job_arg_t **       job_args);
 static void free_job_args(void * arg);
 
 int handle_connections(server_context_t * server)
@@ -180,8 +159,6 @@ int handle_client_event(server_context_t * server, int index)
                 "handling event on client fd [%d]...",
                 client_fd);
 
-    printf("DEBUG: CREATING JOB ARGS\n");
-
     exit_code = create_job_args(
         client_fd, &server->sock_mgr->fd_mutex, server->sock_mgr, &job_args);
     if (E_SUCCESS != exit_code)
@@ -190,8 +167,6 @@ int handle_client_event(server_context_t * server, int index)
         goto END;
     }
 
-    printf("DEBUG: ADDING JOB TO THREADPOOL\n");
-
     exit_code = threadpool_add_job(server->thread_pool,
                                    server->config->client_request,
                                    free_job_args,
@@ -204,8 +179,6 @@ int handle_client_event(server_context_t * server, int index)
         goto END;
     }
 
-    printf("DEBUG: REMOVING FD FROM SOCKET MANAGER\n");
-
     exit_code = sock_fd_remove(server->sock_mgr, index);
     if (E_SUCCESS != exit_code)
     {
@@ -218,48 +191,6 @@ END:
     return exit_code;
 }
 
-void * process_client_request(void * arg)
-{
-    printf("DEBUG 1: INSIDE PROCESS CLIENT REQUEST\n");
-    int         exit_code = E_FAILURE;
-    job_arg_t * job_args  = NULL;
-
-    if (NULL == arg)
-    {
-        print_error("process_client_request(): NULL argument passed.");
-        goto END;
-    }
-
-    job_args = (job_arg_t *)arg;
-
-    exit_code = process_job(job_args->client_fd);
-    if (E_SUCCESS != exit_code)
-    {
-        if (E_CONNECTION_CLOSED == exit_code)
-        {
-            message_log("INFO",
-                        COLOR_RED,
-                        LOG_BOTH,
-                        "closing connection [%d]",
-                        job_args->client_fd);
-
-            close(job_args->client_fd);
-            goto END;
-        }
-        print_error("process_client_request(): Unable to process job.");
-    }
-
-    // Determine whether or not to add back to fd array and/or close client
-    exit_code = sock_fd_add(job_args->sock_mgr, job_args->client_fd);
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("free_job_args(): Unable to add fd to array.");
-    }
-
-END:
-    return NULL;
-}
-
 static int create_job_args(int                client_fd,
                            pthread_mutex_t *  fd_mutex,
                            socket_manager_t * sock_mgr,
@@ -294,7 +225,6 @@ END:
 
 static void free_job_args(void * arg)
 {
-    printf("DEBUG: IN FREE JOB ARGS!");
     job_arg_t * job_args = NULL;
 
     if (NULL == arg)
diff --git a/libraries/Networking/tcp_server/src/socket_manager.c b/libraries/Networking/tcp_server/src/socket_manager.c
index 84fc086..bf982fb 100644
--- a/libraries/Networking/tcp_server/src/socket_manager.c
+++ b/libraries/Networking/tcp_server/src/socket_manager.c
@@ -7,6 +7,9 @@
 #include "socket_manager.h"
 #include "utilities.h"
 
+// static int  mutex_arr_init(int max_fds, pthread_mutex_t ** mutex_arr);
+// static void mutex_arr_destroy(int max_fds, pthread_mutex_t * mutex_arr);
+
 int sock_mgr_init(socket_manager_t * sock_mgr,
                   int                server_fd,
                   int                max_fds,
@@ -33,6 +36,13 @@ int sock_mgr_init(socket_manager_t * sock_mgr,
         goto END;
     }
 
+    // exit_code = mutex_arr_init(max_fds, &sock_mgr->mutex_arr);
+    // if (E_SUCCESS != exit_code)
+    // {
+    //     print_error("sock_mgr_init(): Unable to initialize mutex array.");
+    //     goto END;
+    // }
+
     sock_mgr->fd_count    = 1; // For the server fd
     sock_mgr->fd_capacity = fd_capacity;
     sock_mgr->max_fds     = max_fds;
@@ -45,6 +55,10 @@ END:
     {
         free(sock_mgr->fd_arr);
         sock_mgr->fd_arr = NULL;
+
+        // mutex_arr_destroy(max_fds, sock_mgr->mutex_arr);
+        // free(sock_mgr->mutex_arr);
+        sock_mgr->mutex_arr = NULL;
     }
     return exit_code;
 }
@@ -101,6 +115,8 @@ int sock_fd_remove(socket_manager_t * sock_mgr, int index)
         goto END;
     }
 
+    // int removed_fd = sock_mgr->fd_arr[index].fd;
+
     sock_mgr->fd_count--;
     if (index != sock_mgr->fd_count)
     {
@@ -202,6 +218,10 @@ int close_all_sockets(socket_manager_t * sock_mgr)
 
     free(sock_mgr->fd_arr);
     sock_mgr->fd_arr = NULL;
+
+    // mutex_arr_destroy(sock_mgr->max_fds, sock_mgr->mutex_arr);
+    // free(sock_mgr->mutex_arr);
+    // sock_mgr->mutex_arr = NULL;
     pthread_mutex_destroy(&sock_mgr->fd_mutex);
 
     exit_code = E_SUCCESS;
diff --git a/libraries/Networking/tcp_server/src/tcp_server.c b/libraries/Networking/tcp_server/src/tcp_server.c
index e149092..f40f14a 100644
--- a/libraries/Networking/tcp_server/src/tcp_server.c
+++ b/libraries/Networking/tcp_server/src/tcp_server.c
@@ -12,7 +12,6 @@
 #include "signal_handler.h" // CONINUE_RUNNING, SHUTDOWN, signal_action_setup(), check_for_signals()
 #include "socket_io.h"      // create_socket()
 #include "socket_manager.h" // sock_fd_arr_init(), close_all_sockets()
-#include "system_info.h"
 #include "tcp_server.h"
 #include "utilities.h"
 
@@ -26,39 +25,8 @@
 #define MIN_CLIENTS             1
 #define MAX_CLIENTS             100
 
-/**
- * @brief Initializes the server context with the given configuration.
- *
- * This function sets up the server context by creating and binding a socket,
- * setting it to non-blocking mode, and initializing the socket manager.
- *
- * @param server Pointer to the server context to initialize.
- * @return int E_SUCCESS on success, E_FAILURE on failure.
- */
 static int initialize_server(server_context_t * server);
-
-/**
- * @brief Runs the main server loop, handling incoming connections and signals.
- *
- * This function runs the main server loop, polling for connections and
- * handling them appropriately. It also checks for shutdown signals to
- * gracefully terminate the server.
- *
- * @param server Pointer to the server context.
- * @return int E_SUCCESS on success, E_FAILURE on failure.
- */
 static int run_server_loop(server_context_t * server);
-
-/**
- * @brief Validates the server configuration.
- *
- * This function checks the server configuration for validity, including
- * port number, backlog size, timeout, number of threads, maximum clients,
- * and client request function.
- *
- * @param config Pointer to the server configuration to validate.
- * @return int E_SUCCESS if the configuration is valid, E_FAILURE otherwise.
- */
 static int validate_config(server_config_t * config);
 
 int start_tcp_server(server_config_t * config)
@@ -74,12 +42,6 @@ int start_tcp_server(server_config_t * config)
         goto END;
     }
 
-    message_log("SESSION_START", COLOR_NONE, LOG_FILE, "");
-    log_system_info();
-    message_log("INFO", COLOR_NONE, LOG_BOTH, "TCP server: version 1.0.0");
-    message_log(
-        "INFO", COLOR_NONE, LOG_BOTH, "Loading configuration settings...");
-
     exit_code = validate_config(config);
     if (E_SUCCESS != exit_code)
     {
@@ -98,8 +60,6 @@ int start_tcp_server(server_config_t * config)
     server.thread_pool = thread_pool;
     server.config      = config;
 
-    message_log("INFO", COLOR_NONE, LOG_BOTH, "Initializing server...");
-
     exit_code = initialize_server(&server);
     if (E_SUCCESS != exit_code)
     {
@@ -107,9 +67,6 @@ int start_tcp_server(server_config_t * config)
         goto END;
     }
 
-    message_log(
-        "INFO", COLOR_NONE, LOG_BOTH, "Listening on port: %s...", config->port);
-
     exit_code = run_server_loop(&server);
     if (E_SUCCESS != exit_code)
     {
@@ -142,15 +99,11 @@ static int run_server_loop(server_context_t * server)
         signal = check_for_signals();
         if (SHUTDOWN == signal)
         {
-            message_log("INFO",
-                        COLOR_RED,
-                        LOG_BOTH,
-                        "Shutdown signal received, shutting down...");
-            exit_code = E_SUCCESS;
+            printf("Shutdown signal received.\n");
             goto END;
         }
 
-        // Create local copies in order to avoid race conditions
+        // Create local variable copies in order to avoid race conditions
         pthread_mutex_lock(&server->sock_mgr->fd_mutex);
         local_fd_arr   = server->sock_mgr->fd_arr;
         local_fd_count = server->sock_mgr->fd_count;
@@ -275,6 +228,14 @@ static int initialize_server(server_context_t * server)
         goto END;
     }
 
+    message_log("INFO", COLOR_NONE, LOG_FILE, "server started...");
+    message_log("INFO",
+                COLOR_GREEN,
+                LOG_BOTH,
+                "server socket [%d] listening on port: %s",
+                server->fd,
+                server->config->port);
+
 END:
     freeaddrinfo(addr_list);
     return exit_code;
diff --git a/libraries/Threading/src/threadpool.c b/libraries/Threading/src/threadpool.c
index 1eedccf..c1d3c59 100644
--- a/libraries/Threading/src/threadpool.c
+++ b/libraries/Threading/src/threadpool.c
@@ -7,11 +7,12 @@
 #include "threadpool.h"
 #include "utilities.h"
 
-#define ACTIVATE     1 // Activate the threadpool
-#define SHUTDOWN     0 // Shutdown the threadpool
-#define EMPTY        0 // Work queue is empty
-#define NOT_EMPTY    1 // Work queue is not empty
-#define KEEP_RUNNING 0 // Default signal for the signal handler
+#define QUEUE_MAX_CAPACITY 1024 // Maximum size for a queue
+#define ACTIVATE           1    // Activate the threadpool
+#define SHUTDOWN           0    // Shutdown the threadpool
+#define EMPTY              0    // Work queue is empty
+#define NOT_EMPTY          1    // Work queue is not empty
+#define KEEP_RUNNING       0    // Default signal for the signal handler
 
 /**
  * @brief A struct for a job
@@ -247,8 +248,6 @@ int threadpool_add_job(threadpool_t * pool_p,
         goto END;
     }
 
-    printf("DEBUG: Job function pointer address: %p\n", (void *)(uintptr_t)job);
-
     new_job = create_job(job, del_f, arg_p);
     if (NULL == new_job)
     {
@@ -269,7 +268,6 @@ int threadpool_add_job(threadpool_t * pool_p,
     pthread_mutex_unlock(&pool_p->mutex);
 
     exit_code = E_SUCCESS;
-    printf("DEBUG ADDED JOB TO THREADPOOL\n");
 END:
     return exit_code;
 }
@@ -303,7 +301,7 @@ static int threadpool_setup(threadpool_t * threadpool_p, size_t thread_count)
     threadpool_p->condition_initialized = true;
 
     // 3. Setup the job queue
-    threadpool_p->job_queue = queue_init(NULL);
+    threadpool_p->job_queue = queue_init(QUEUE_MAX_CAPACITY, NULL);
     if (NULL == threadpool_p->job_queue)
     {
         print_error("threadpool_create(): Unable to initialize queue.");
@@ -376,14 +374,6 @@ static void * start_thread(void * pool_p)
 
         pthread_mutex_unlock(&threadpool_p->mutex);
 
-        printf("DEBUG ABOUT TO PROCESS JOB\n");
-
-        if (NULL == job_p)
-        {
-            print_error("start_thread(): NULL JOB WTF!");
-            goto END;
-        }
-
         exit_code = process_job(job_p);
         if (E_SUCCESS != exit_code)
         {
@@ -434,7 +424,7 @@ static int wait_for_job(threadpool_t * threadpool_p)
         goto END;
     }
 
-    while ((true == queue_is_empty(threadpool_p->job_queue)) &&
+    while ((EMPTY == queue_emptycheck(threadpool_p->job_queue)) &&
            (SHUTDOWN != threadpool_p->signal))
     {
         pthread_mutex_lock(&signal_flag_mutex);
@@ -473,7 +463,7 @@ static int get_next_job(threadpool_t ** threadpool_p,
     }
 
     if ((SHUTDOWN == (*threadpool_p)->signal) &&
-        (true == queue_is_empty((*threadpool_p)->job_queue)))
+        (EMPTY == queue_emptycheck((*threadpool_p)->job_queue)))
     {
         goto END;
     }
@@ -501,7 +491,7 @@ static int process_job(job_t * job_p)
 {
     int exit_code = E_FAILURE;
 
-    if ((NULL == job_p) || (NULL == job_p->job) || (NULL == job_p->args_p))
+    if (NULL == job_p)
     {
         print_error("process_job(): NULL job passed.");
         goto END;
@@ -510,8 +500,6 @@ static int process_job(job_t * job_p)
     if (NULL != job_p->job)
     {
         // Attempt to run the job
-        printf("DEBUG: Executing job function at: %p\n",
-               (void *)(uintptr_t)job_p->job);
         job_p->job(job_p->args_p);
     }
 
diff --git a/projects/local/client_2.py b/projects/local/client_2.py
deleted file mode 100755
index e0b5c84..0000000
--- a/projects/local/client_2.py
+++ /dev/null
@@ -1,70 +0,0 @@
-#!/usr/bin/env python3
-
-import cmd
-import socket
-import struct
-
-HOST = "127.0.0.1"
-# HOST = "192.168.86.150"  # Replace with your server IP if needed
-PORT = 17337  # Must match the port your server is listening on
-
-
-class TCPClient(cmd.Cmd):
-    intro = "Welcome to the LED control client. Type help or ? to list commands.\n"
-    prompt = "(client) "
-
-    def __init__(self):
-        super().__init__()
-        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        try:
-            self.client_socket.connect((HOST, PORT))
-            print(f"Connected to server at {HOST}:{PORT}")
-        except ConnectionRefusedError:
-            print(f"Unable to connect to server at {HOST}:{PORT}")
-            exit(1)
-
-    def send_command(self, opcode):
-        """Send a single-byte opcode to the server."""
-        try:
-            self.client_socket.sendall(struct.pack("B", opcode))
-            # response = self.client_socket.recv(1024)
-            # print(f"Received: {response}")
-        except (ConnectionResetError, BrokenPipeError):
-            print("Connection lost with the server.")
-            self.client_socket.close()
-            exit(1)
-
-    def do_green_on(self, arg):
-        """Turn on the green light."""
-        self.send_command(0x04)  # GREEN_ON
-
-    def do_green_off(self, arg):
-        """Turn off the green light."""
-        self.send_command(0x05)  # GREEN_OFF
-
-    def do_red_on(self, arg):
-        """Turn on the red light."""
-        self.send_command(0x06)  # RED_ON
-
-    def do_red_off(self, arg):
-        """Turn off the red light."""
-        self.send_command(0x07)  # RED_OFF
-
-    def do_yellow_on(self, arg):
-        """Turn on the yellow light."""
-        self.send_command(0x08)  # YELLOW_ON
-
-    def do_yellow_off(self, arg):
-        """Turn off the yellow light."""
-        self.send_command(0x09)  # YELLOW_OFF
-
-    def do_exit(self, arg):
-        """Close the connection and exit the client."""
-        print("Closing connection...")
-        self.send_command(0x03)  # CLOSE_CONNECTION
-        self.client_socket.close()
-        return True
-
-
-if __name__ == "__main__":
-    TCPClient().cmdloop()
diff --git a/projects/remote/include/lights.h b/projects/remote/include/lights.h
deleted file mode 100644
index d18e233..0000000
--- a/projects/remote/include/lights.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/**
- * @file lights.h
- *
- * @brief
- */
-#ifndef _LIGHTS_H
-#define _LIGHTS_H
-
-int lights_init();
-int lights_destroy();
-int light_green_on();
-int light_green_off();
-int light_red_on();
-int light_red_off();
-int light_yellow_on();
-int light_yellow_off();
-
-#endif /* _LIGHTS_H */
-
-/*** end of file ***/
diff --git a/projects/remote/include/opcodes.h b/projects/remote/include/opcodes.h
index 5878302..939ac86 100644
--- a/projects/remote/include/opcodes.h
+++ b/projects/remote/include/opcodes.h
@@ -16,12 +16,6 @@
 #define AUTHENTICATION   0x01
 #define MESSAGE          0x02
 #define CLOSE_CONNECTION 0x03
-#define GREEN_ON         0x04
-#define GREEN_OFF        0x05
-#define RED_ON           0x06
-#define RED_OFF          0x07
-#define YELLOW_ON        0x08
-#define YELLOW_OFF       0x09
 
 //
 // --------------------------------RETURN CODES--------------------------------
diff --git a/projects/remote/src/lights.c b/projects/remote/src/lights.c
deleted file mode 100644
index 85302f8..0000000
--- a/projects/remote/src/lights.c
+++ /dev/null
@@ -1,153 +0,0 @@
-#include "lights.h"
-#include "signal_handler.h"
-#include "socket_io.h"
-#include "tcp_server.h"
-#include "utilities.h"
-
-#include <unistd.h>
-
-#if defined(__aarch64__) || defined(__arm__)
-#include <bcm2835.h> // Include only on ARM-based systems (Raspberry Pi)
-#endif
-
-#define MAX_BUFF_SIZE    14
-#define PLACEHOLDER_NUM  10
-#define BCM_INIT_FAILURE 0
-
-int lights_init()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    if (!bcm2835_init())
-    {
-        print_error("lights_init(): Failed to initialize bcm2835.");
-        goto END;
-    }
-
-    // Set GPIO pins as outputs
-    bcm2835_gpio_fsel(RPI_BPLUS_GPIO_J8_40, BCM2835_GPIO_FSEL_OUTP);
-    bcm2835_gpio_fsel(RPI_BPLUS_GPIO_J8_38, BCM2835_GPIO_FSEL_OUTP);
-    bcm2835_gpio_fsel(RPI_BPLUS_GPIO_J8_36, BCM2835_GPIO_FSEL_OUTP);
-
-#else
-    printf("lights_init(): Running on non-ARM system. Skipping GPIO setup.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    // END:
-    return exit_code;
-}
-
-int lights_destroy()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    // Ensure LEDs are off
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_40, LOW);
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_38, LOW);
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_36, LOW);
-
-    if (!bcm2835_close())
-    {
-        print_error("lights_destroy(): Failed to properly close bcm2835.");
-        goto END;
-    }
-
-#else
-    printf(
-        "lights_destroy(): Running on non-ARM system. Skipping GPIO "
-        "cleanup.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    // END:
-    return exit_code;
-}
-
-int light_green_on()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_40, HIGH);
-#else
-    printf("light_green_on(): Green LED is on.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    return exit_code;
-}
-
-int light_green_off()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_40, LOW);
-#else
-    printf("light_green_off(): Green LED is off.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    return exit_code;
-}
-
-int light_red_on()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_38, HIGH);
-#else
-    printf("light_red_on(): Red LED is on.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    return exit_code;
-}
-
-int light_red_off()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_38, LOW);
-#else
-    printf("light_red_off(): Red LED is off.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    return exit_code;
-}
-
-int light_yellow_on()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_36, HIGH);
-#else
-    printf("light_yellow_on(): Yellow LED is on.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    return exit_code;
-}
-
-int light_yellow_off()
-{
-    int exit_code = E_FAILURE;
-
-#if defined(__aarch64__) || defined(__arm__)
-    bcm2835_gpio_write(RPI_BPLUS_GPIO_J8_36, LOW);
-#else
-    printf("light_yellow_off(): Yellow LED is off.\n");
-#endif
-
-    exit_code = E_SUCCESS;
-    return exit_code;
-}
-
-/*** end of file ***/
diff --git a/projects/remote/src/main.c b/projects/remote/src/main.c
index 03de546..244bc52 100644
--- a/projects/remote/src/main.c
+++ b/projects/remote/src/main.c
@@ -2,7 +2,6 @@
 #include <stdlib.h>
 
 #include "job_handler.h"
-#include "lights.h"
 #include "signal_handler.h"
 #include "tcp_server.h"
 #include "utilities.h"
@@ -32,19 +31,12 @@ int main(void)
         goto END;
     }
 
-    exit_code = lights_init();
-    if (E_SUCCESS != exit_code)
-    {
-        print_error("main(): Unable to initialize lights.");
-        goto END;
-    }
-
     config->port           = "17337";
     config->max_clients    = MAX_CLIENTS;
     config->num_threads    = NUM_THREADS;
     config->backlog_size   = BACKLOG_SIZE;
     config->timeout        = TIMEOUT;
-    config->client_request = (JOB_F)process_client_request;
+    config->client_request = process_client_request;
 
     exit_code = start_tcp_server(config);
     if (E_SUCCESS != exit_code)
@@ -54,7 +46,6 @@ int main(void)
     }
 
 END:
-    lights_destroy();
     free(config);
     config = NULL;
     return exit_code;
diff --git a/projects/remote/src/request_handler.c b/projects/remote/src/request_handler.c
index 12fe2e4..13bc95b 100644
--- a/projects/remote/src/request_handler.c
+++ b/projects/remote/src/request_handler.c
@@ -4,19 +4,60 @@
 #include <unistd.h>
 
 #include "job_handler.h"
-#include "lights.h"
 #include "opcodes.h"
 #include "packets.h"
 #include "socket_io.h"
 #include "utilities.h"
 
+int message(int client_fd);
+int process_job(int client_fd);
+
+void * process_client_request(void * arg)
+{
+    int         exit_code = E_FAILURE;
+    job_arg_t * job_args  = NULL;
+
+    if (NULL == arg)
+    {
+        print_error("process_client_request(): NULL argument passed.");
+        goto END;
+    }
+
+    job_args = (job_arg_t *)arg;
+
+    exit_code = process_job(job_args->client_fd);
+    if (E_SUCCESS != exit_code)
+    {
+        if (E_CONNECTION_CLOSED == exit_code)
+        {
+            message_log("INFO",
+                        COLOR_RED,
+                        LOG_BOTH,
+                        "closing connection [%d]",
+                        job_args->client_fd);
+
+            close(job_args->client_fd);
+            goto END;
+        }
+        print_error("process_client_request(): Unable to process job.");
+    }
+
+    // Determine whether or not to add back to fd array and/or close client
+    exit_code = sock_fd_add(job_args->sock_mgr, job_args->client_fd);
+    if (E_SUCCESS != exit_code)
+    {
+        print_error("free_job_args(): Unable to add fd to array.");
+    }
+
+END:
+    return NULL;
+}
+
 int process_job(int client_fd)
 {
     int     exit_code = E_FAILURE;
     uint8_t opcode    = -1;
 
-    printf("DEBUG 2: INSIDE PROCESS JOB\n");
-
     exit_code = recv_all_data(client_fd, &opcode, sizeof(uint8_t));
     if (E_SUCCESS != exit_code)
     {
@@ -25,56 +66,11 @@ int process_job(int client_fd)
 
     switch (opcode)
     {
-        case GREEN_ON:
-            exit_code = light_green_on();
+        case MESSAGE:
+            exit_code = message(client_fd);
             if (E_SUCCESS != exit_code)
             {
-                print_error("process_job(): failed to turn green light on.");
-                goto END;
-            }
-            break;
-
-        case GREEN_OFF:
-            exit_code = light_green_off();
-            if (E_SUCCESS != exit_code)
-            {
-                print_error("process_job(): failed to turn green light off.");
-                goto END;
-            }
-            break;
-
-        case RED_ON:
-            exit_code = light_red_on();
-            if (E_SUCCESS != exit_code)
-            {
-                print_error("process_job(): failed to turn red light on.");
-                goto END;
-            }
-            break;
-
-        case RED_OFF:
-            exit_code = light_red_off();
-            if (E_SUCCESS != exit_code)
-            {
-                print_error("process_job(): failed to turn red light off.");
-                goto END;
-            }
-            break;
-
-        case YELLOW_ON:
-            exit_code = light_yellow_on();
-            if (E_SUCCESS != exit_code)
-            {
-                print_error("process_job(): failed to turn yellow light on.");
-                goto END;
-            }
-            break;
-
-        case YELLOW_OFF:
-            exit_code = light_yellow_off();
-            if (E_SUCCESS != exit_code)
-            {
-                print_error("process_job(): failed to turn yellow light off.");
+                print_error("process_job(): Unable to process message.");
                 goto END;
             }
             break;
@@ -93,3 +89,75 @@ int process_job(int client_fd)
 END:
     return exit_code;
 }
+
+int message(int client_fd)
+{
+    int           exit_code   = E_FAILURE;
+    uint32_t      message_len = 0;
+    unsigned char padding[3]  = { 0 };
+    char *        message     = NULL;
+
+    // Read padding
+    exit_code = recv_all_data(client_fd, padding, sizeof(padding));
+    if (E_SUCCESS != exit_code)
+    {
+        print_error("message(): Unable to get padding.");
+        goto END;
+    }
+
+    // Read message length
+    exit_code = recv_all_data(client_fd, &message_len, sizeof(message_len));
+    if (E_SUCCESS != exit_code)
+    {
+        print_error("message(): Unable to get message length.");
+        goto END;
+    }
+
+    message_len = ntohl(message_len);
+
+    // Verify the message length to ensure it is within a reasonable range
+    if (message_len >
+        1024) // Assuming 1024 is the maximum reasonable length for a message
+    {
+        print_error("message(): Message length is unreasonably large.");
+        goto END;
+    }
+
+    // Allocate memory for the message
+    message = calloc(1, message_len + 1);
+    if (NULL == message)
+    {
+        exit_code = E_FAILURE;
+        print_error("message(): Memory allocation failure.");
+        goto END;
+    }
+
+    exit_code = recv_all_data(client_fd, message, message_len);
+    if (E_SUCCESS != exit_code)
+    {
+        print_error("message(): Unable to get message.");
+        goto END;
+    }
+
+    if (MAX_MSG_SIZE > message_len)
+    {
+        message_log("INFO",
+                    COLOR_YELLOW,
+                    LOG_BOTH,
+                    "MESSAGE from [%d]: %s",
+                    client_fd,
+                    message);
+    }
+    else
+    {
+        message_log(
+            "INFO", COLOR_YELLOW, LOG_BOTH, "message is too long to display");
+    }
+
+    exit_code = E_SUCCESS;
+
+END:
+    free(message);
+    message = NULL;
+    return exit_code;
+}
\ No newline at end of file
diff --git a/training/pointers/demos/1_basic_pointer_usage/local/src/1_basic_pointer_usage.c b/training/pointers/demos/1_basic_pointer_usage/local/src/1_basic_pointer_usage.c
index b641678..9b20a02 100644
--- a/training/pointers/demos/1_basic_pointer_usage/local/src/1_basic_pointer_usage.c
+++ b/training/pointers/demos/1_basic_pointer_usage/local/src/1_basic_pointer_usage.c
@@ -14,8 +14,8 @@
 
 int main()
 {
-    int   number   = 10;
-    int * p_number = NULL;
+    int number = 10;
+    int *p_number = NULL;
 
     p_number = &number;
 
diff --git a/training/pointers/exercises/1_swap/local/src/swap.c b/training/pointers/exercises/1_swap/local/src/swap.c
index 170a28c..633ea04 100644
--- a/training/pointers/exercises/1_swap/local/src/swap.c
+++ b/training/pointers/exercises/1_swap/local/src/swap.c
@@ -2,18 +2,19 @@
 
 #include "utilities.h"
 
-int swap(int * p_num_1, int * p_num_2)
+int swap(int *p_num_1, int *p_num_2)
 {
     int exit_code = E_FAILURE;
-    int temp      = 0;
+    int temp = 0;
 
     if ((NULL == p_num_1) || (NULL == p_num_2))
     {
+        print_error("swap(): NULL argument passed.");
         exit_code = E_NULL_POINTER;
         goto END;
     }
 
-    temp     = *p_num_1;
+    temp = *p_num_1;
     *p_num_1 = *p_num_2;
     *p_num_2 = temp;
 
diff --git a/training/pointers/exercises/1_swap/local/tests/swap_tests.c b/training/pointers/exercises/1_swap/local/tests/swap_tests.c
index 0fd8626..475c5ed 100644
--- a/training/pointers/exercises/1_swap/local/tests/swap_tests.c
+++ b/training/pointers/exercises/1_swap/local/tests/swap_tests.c
@@ -9,7 +9,7 @@
 void swap_first_parameter_null(void)
 {
     int exit_code = E_FAILURE;
-    int num_2     = 30;
+    int num_2 = 30;
 
     exit_code = swap(NULL, &num_2);
     CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
@@ -18,7 +18,7 @@ void swap_first_parameter_null(void)
 void swap_second_parameter_null(void)
 {
     int exit_code = E_FAILURE;
-    int num_1     = 10;
+    int num_1 = 10;
 
     exit_code = swap(&num_1, NULL);
     CU_ASSERT_EQUAL(exit_code, E_NULL_POINTER);
@@ -27,8 +27,8 @@ void swap_second_parameter_null(void)
 void swap_10_and_30(void)
 {
     int exit_code = E_FAILURE;
-    int num_1     = 10;
-    int num_2     = 30;
+    int num_1 = 10;
+    int num_2 = 30;
 
     exit_code = swap(&num_1, &num_2);
     CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
@@ -40,8 +40,8 @@ void swap_10_and_30(void)
 void swap_20_and_50(void)
 {
     int exit_code = E_FAILURE;
-    int num_1     = 20;
-    int num_2     = 50;
+    int num_1 = 20;
+    int num_2 = 50;
 
     exit_code = swap(&num_1, &num_2);
     CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
@@ -53,8 +53,8 @@ void swap_20_and_50(void)
 void swap_neg19_and_87(void)
 {
     int exit_code = E_FAILURE;
-    int num_1     = (-19);
-    int num_2     = 87;
+    int num_1 = (-19);
+    int num_2 = 87;
 
     exit_code = swap(&num_1, &num_2);
     CU_ASSERT_EQUAL(exit_code, E_SUCCESS);
@@ -64,16 +64,14 @@ void swap_neg19_and_87(void)
 }
 
 static CU_TestInfo swap_tests[] = {
-    { "Swap - First Parameter is NULL", swap_first_parameter_null },
-    { "Swap - Second Paramater is NULL", swap_second_parameter_null },
-    { "Swap - 10 and 30", swap_10_and_30 },
-    { "Swap - 20 and 50", swap_20_and_50 },
-    { "Swap - (-19) and 87", swap_neg19_and_87 },
-    CU_TEST_INFO_NULL
-};
+    {"Swap - First Parameter is NULL", swap_first_parameter_null},
+    {"Swap - Second Paramater is NULL", swap_second_parameter_null},
+    {"Swap - 10 and 30", swap_10_and_30},
+    {"Swap - 20 and 50", swap_20_and_50},
+    {"Swap - (-19) and 87", swap_neg19_and_87},
+    CU_TEST_INFO_NULL};
 
 CU_SuiteInfo swap_test_suite = {
-    "Pointers - Exercise 1 - Swap: Tests", NULL, NULL, NULL, NULL, swap_tests
-};
+    "Pointers - Exercise 1 - Swap: Tests", NULL, NULL, NULL, NULL, swap_tests};
 
 /*** end of file ***/
